#!/bin/bash
set -e

# --- Configuration ---
VM_NAME="dev-vm-docker-host"
TEMPLATES_DIR="$HOME/.dev-envs/templates"
# --- End Configuration ---

# --- Helper Functions ---
function usage() {
    echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
    echo ""
    echo "A script to build and run isolated development containers using OrbStack VMs."
    echo ""
    echo "Commands:"
    echo "  run      Build and run the container (default)"
    echo "  build    Build the container image only"
    echo "  clean    Remove existing container and image"
    echo ""
    echo "Template Commands:"
    echo "  new <language>       Create a Dockerfile from template"
    echo "  list                 List available language templates"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -f, --file     Specify Dockerfile path (default: ./Dockerfile)"
    echo "  -t, --tag      Specify custom image tag"
    echo "  -n, --name     Specify custom container name"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0")                       # Build and run with default Dockerfile"
    echo "  $(basename "$0") build                # Build image only"
    echo "  $(basename "$0") -f Dockerfile.dev    # Use custom Dockerfile"
    echo "  $(basename "$0") new python           # Create from Python template"
    echo "  $(basename "$0") new python-3.11      # Create from specific Python version"
    echo "  $(basename "$0") list                 # Show available templates with versions"
    echo ""
    echo "Requirements:"
    echo "  - Dockerfile in current directory (or specified with -f)"
    echo "  - OrbStack VM '$VM_NAME' available"
    exit 0
}

function list_templates() {
    echo "Available Dockerfile templates:"
    if [[ -d "$TEMPLATES_DIR" ]]; then
        local templates_found=false
        
        # Create a simple formatted list
        printf "  %-12s %s\n" "Language" "Available Versions"
        printf "  %-12s %s\n" "--------" "------------------"
        
        # Process templates dynamically by discovering all languages
        local all_languages=$(ls "$TEMPLATES_DIR"/Dockerfile-* 2>/dev/null | grep -v '\.backup\.' | sed 's/.*Dockerfile-//' | sed 's/-.*$//' | sort -u)
        
        for lang in $all_languages; do
            local versions=""
            local version_count=0
            
            # Find all versions for this language
            for template_path in "$TEMPLATES_DIR/Dockerfile-$lang"-*; do
                if [[ -f "$template_path" ]] && [[ "$template_path" != *".backup."* ]]; then
                    local template_name=$(basename "$template_path" | sed 's/Dockerfile-//')
                    local version="${template_name#*-}"
                    
                    if [[ $version_count -eq 0 ]]; then
                        versions="$version"
                    else
                        versions="$versions, $version"
                    fi
                    ((version_count++))
                    found_templates=true
                    templates_found=true
                fi
            done
            
            # Display if we found templates for this language
            if [[ $version_count -gt 0 ]]; then
                printf "  %-12s %s\n" "$lang" "$versions"
            fi
        done
        
        if [[ "$templates_found" == false ]]; then
            echo "  (No templates found - run installer first)"
        fi
    else
        echo "  (Templates directory not found - run installer first)"
    fi
    exit 0
}

function create_from_template() {
    local language="$1"
    local template_file=""
    local target_file="./Dockerfile"
    
    if [[ ! -d "$TEMPLATES_DIR" ]]; then
        echo "âŒ Error: Templates directory not found at $TEMPLATES_DIR"
        echo "Please run the installer first."
        exit 1
    fi
    
    # Smart template matching logic
    # 1. Try exact match first (e.g., "python-3.11" -> "Dockerfile-python-3.11")
    if [[ -f "$TEMPLATES_DIR/Dockerfile-$language" ]]; then
        template_file="$TEMPLATES_DIR/Dockerfile-$language"
    else
        # 2. Try to find templates that start with the language name
        local matching_templates=($(find "$TEMPLATES_DIR" -name "Dockerfile-${language}-*" -type f | grep -v '\.backup\.'))
        
        if [[ ${#matching_templates[@]} -eq 1 ]]; then
            # Found exactly one versioned template for this language
            template_file="${matching_templates[0]}"
            local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
            echo "ðŸ“‹ Using template: $template_name"
        elif [[ ${#matching_templates[@]} -gt 1 ]]; then
            # Multiple versions available, ask user to be specific
            echo "âŒ Error: Multiple versions available for '$language'."
            echo "Please specify the version you want:"
            echo ""
            printf "  %-20s %s\n" "Template Name" "Usage"
            printf "  %-20s %s\n" "-------------" "-----"
            for template in "${matching_templates[@]}"; do
                local template_name=$(basename "$template" | sed 's/Dockerfile-//')
                printf "  %-20s %s\n" "$template_name" "dev new $template_name"
            done
            echo ""
            echo "Or run 'dev list' to see all available options."
            exit 1
        else
            # No templates found for this language
            echo "âŒ Error: No template found for '$language'."
            echo "Available templates:"
            list_templates
            exit 1
        fi
    fi
    
    if [[ -f "$target_file" ]]; then
        echo "âš ï¸  Warning: Dockerfile already exists in current directory."
        echo -n "Do you want to overwrite it? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled."
            exit 0
        fi
    fi
    
    cp "$template_file" "$target_file" || {
        echo "âŒ Error: Failed to copy template"
        exit 1
    }
    
    echo "âœ… Created Dockerfile from $language template"
    echo "You can now run 'dev' to build and run your container."
    exit 0
}

# --- Parse Arguments ---
DOCKERFILE="Dockerfile"
COMMAND="run"
CUSTOM_TAG=""
CUSTOM_NAME=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        list)
            list_templates
            ;;
        new)
            if [[ -z "$2" ]]; then
                echo "âŒ Error: new requires a language argument"
                echo "Use 'dev list' to see available options."
                exit 1
            fi
            create_from_template "$2"
            ;;
        -f|--file)
            DOCKERFILE="$2"
            shift 2
            ;;
        -t|--tag)
            CUSTOM_TAG="$2"
            shift 2
            ;;
        -n|--name)
            CUSTOM_NAME="$2"
            shift 2
            ;;
        run|build|clean)
            COMMAND="$1"
            shift
            ;;
        *)
            echo "âŒ Error: Unknown option '$1'"
            echo "Use --help for usage information."
            exit 1
            ;;
    esac
done

# --- Validate Requirements ---
if [[ "$COMMAND" != "clean" ]]; then
    if [ ! -f "$DOCKERFILE" ]; then
        echo "âŒ Error: No Dockerfile found at '$DOCKERFILE'"
        echo "Use -f to specify a different Dockerfile path, or --help for usage information."
        exit 1
    fi
fi

# --- Validate Requirements ---
if [[ "$COMMAND" != "clean" ]]; then
    if [ ! -f "$DOCKERFILE" ]; then
        echo "âŒ Error: No Dockerfile found at '$DOCKERFILE'"
        echo "Use -f to specify a different Dockerfile path, or --help for usage information."
        exit 1
    fi
fi

# --- Generate Names ---
PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
IMAGE_NAME="${CUSTOM_TAG:-dev-img-${PROJECT_NAME}}"
CONTAINER_NAME="${CUSTOM_NAME:-dev-ctn-${PROJECT_NAME}}"

# --- Helper Functions for Container Operations ---
ensure_vm_running() {
    if ! orb status "$VM_NAME" 2>/dev/null | grep -q "running"; then
        echo "   -> Starting Docker Host VM..."
        orb start "$VM_NAME"
    fi
}

build_image() {
    echo "   -> Building Docker image '$IMAGE_NAME'..."
    orb -m "$VM_NAME" sudo docker build -f "$DOCKERFILE" -t "$IMAGE_NAME" .
}

cleanup_existing_container() {
    if orb -m "$VM_NAME" sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "   -> Stopping existing container..."
        orb -m "$VM_NAME" sudo docker stop "$CONTAINER_NAME" >/dev/null 2>&1
        orb -m "$VM_NAME" sudo docker rm "$CONTAINER_NAME" >/dev/null 2>&1
    fi
}

# --- Main Logic ---
case $COMMAND in
    run)
        echo "ðŸš€ Preparing isolated container for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        cleanup_existing_container
        echo "âœ… Connecting to container. Your project folder is at '/app'."
        orb -m "$VM_NAME" sudo docker run -it --rm \
            -v "$(pwd):/app" \
            --name "$CONTAINER_NAME" \
            "$IMAGE_NAME"
        ;;
        
    build)
        echo "ðŸ”¨ Building container image for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        echo "âœ… Image '$IMAGE_NAME' built successfully."
        ;;
        
    clean)
        echo "ðŸ§¹ Cleaning up containers and images for '$PROJECT_NAME'..."
        ensure_vm_running
        cleanup_existing_container
        if orb -m "$VM_NAME" sudo docker images --format '{{.Repository}}' | grep -q "^${IMAGE_NAME}$"; then
            echo "   -> Removing image '$IMAGE_NAME'..."
            orb -m "$VM_NAME" sudo docker rmi "$IMAGE_NAME" >/dev/null 2>&1
        fi
        echo "âœ… Cleanup complete."
        ;;
esac
