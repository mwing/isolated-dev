#!/bin/bash
set -e

# ==============================================================================
# CONFIGURATION
# ==============================================================================

DEFAULT_VM_NAME="dev-vm-docker-host"
TEMPLATES_DIR="$HOME/.dev-envs/templates"
CONFIG_DIR="$HOME/.dev-envs"
GLOBAL_CONFIG="$CONFIG_DIR/config.yaml"
PROJECT_CONFIG=".devenv.yaml"

# Template skeleton directories (installed by install.sh)
# These contain template files with {{PLACEHOLDER}} variables that are 
SKELETONS_DIR="$CONFIG_DIR/skeletons"
DOCKERFILE_SKELETONS="$SKELETONS_DIR/dockerfiles"
SCAFFOLDING_SKELETONS="$SKELETONS_DIR/scaffolding"

# ==============================================================================
# CONFIGURATION FUNCTIONS
# ==============================================================================

function load_config() {
    # Set defaults
    VM_NAME="$DEFAULT_VM_NAME"
    DEFAULT_TEMPLATE=""
    AUTO_START_VM="true"
    CONTAINER_PREFIX="dev"
    
    # Load global config if it exists
    if [[ -f "$GLOBAL_CONFIG" ]]; then
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            # Skip section headers like [profile.name]
            [[ "$line" =~ ^\[.*\] ]] && continue
            
            # Only process lines with equals sign
            if [[ "$line" =~ ^[[:space:]]*([^=]+)=[[:space:]]*(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                
                # Clean up key and value
                key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/^"//;s/"$//')
                
                case "$key" in
                    vm_name) VM_NAME="$value" ;;
                    default_template) DEFAULT_TEMPLATE="$value" ;;
                    auto_start_vm) AUTO_START_VM="$value" ;;
                    container_prefix) CONTAINER_PREFIX="$value" ;;
                esac
            fi
        done < "$GLOBAL_CONFIG"
    fi
    
    # Load project-local config if it exists (overrides global)
    if [[ -f "$PROJECT_CONFIG" ]]; then
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            # Skip section headers like [profile.name]
            [[ "$line" =~ ^\[.*\] ]] && continue
            
            # Only process lines with equals sign
            if [[ "$line" =~ ^[[:space:]]*([^=]+)=[[:space:]]*(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                
                # Clean up key and value
                key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/^"//;s/"$//')
                
                case "$key" in
                    vm_name) VM_NAME="$value" ;;
                    default_template) DEFAULT_TEMPLATE="$value" ;;
                    auto_start_vm) AUTO_START_VM="$value" ;;
                    container_prefix) CONTAINER_PREFIX="$value" ;;
                esac
            fi
        done < "$PROJECT_CONFIG"
    fi
}

function create_default_config() {
    if [[ ! -f "$GLOBAL_CONFIG" ]]; then
        mkdir -p "$CONFIG_DIR"
        if [[ -f "$SCAFFOLDING_SKELETONS/basic/global-config.yaml" ]]; then
            cp "$SCAFFOLDING_SKELETONS/basic/global-config.yaml" "$GLOBAL_CONFIG"
        else
            echo "‚ùå Error: Global config skeleton not found"
            return 1
        fi
        echo "üìù Created default config at $GLOBAL_CONFIG"
        echo "   Edit this file to customize your development environment defaults."
    fi
}

function create_dockerfile_from_skeleton() {
    local language="$1"
    local version="$2"
    local output_file="$3"
    local skeleton_file="$DOCKERFILE_SKELETONS/$language.dockerfile"
    
    if [[ ! -f "$skeleton_file" ]]; then
        echo "‚ùå Error: Skeleton file not found: $skeleton_file"
        return 1
    fi
    
    # Replace placeholders in skeleton with actual values
    sed "s/{{VERSION}}/$version/g" "$skeleton_file" > "$output_file"
    return 0
}

function copy_scaffolding_files() {
    local language="$1" 
    local project_name="$2"
    local go_version="$3"  # Optional, for Go language
    local scaffolding_dir="$SCAFFOLDING_SKELETONS/$language"
    
    if [[ ! -d "$scaffolding_dir" ]]; then
        echo "‚ùå Error: Scaffolding directory not found: $scaffolding_dir"
        return 1
    fi
    
    # Copy all files from scaffolding directory, replacing placeholders
    for file in "$scaffolding_dir"/*; do
        [[ ! -f "$file" ]] && continue
        
        local filename=$(basename "$file")
        
        # Replace placeholders in file content based on file type
        case "$filename" in
            "package.json")
                sed "s/{{PROJECT_NAME}}/$project_name/g" "$file" > "$filename"
                ;;
            "go.mod")
                sed -e "s/{{PROJECT_NAME}}/$project_name/g" -e "s/{{GO_VERSION}}/$go_version/g" "$file" > "$filename"
                ;;
            "Cargo.toml")
                sed "s/{{PROJECT_NAME}}/$project_name/g" "$file" > "$filename"
                ;;
            "pom.xml")
                sed "s/{{PROJECT_NAME}}/$project_name/g" "$file" > "$filename"
                ;;
            "composer.json")
                sed "s/{{PROJECT_NAME}}/$project_name/g" "$file" > "$filename"
                ;;
            *)
                cp "$file" "$filename"
                ;;
        esac
    done
    
    return 0
}

# ==============================================================================
# UTILITY FUNCTIONS
# ==============================================================================

function handle_env_command() {
    local env_command="$1"
    local env_name="$2"
    shift 2  # Remove command and env name
    
    # Process additional flags
    while [[ $# -gt 0 ]]; do
        case $1 in
            --yes|-y)
                AUTO_YES=true
                shift
                ;;
            *)
                echo "‚ùå Error: Unknown flag for 'env' command: $1"
                exit 1
                ;;
        esac
    done
    
    local setup_dir="$HOME/.dev-envs/setups"
    
    case "$env_command" in
        new|up|down|rm|status)
            if [[ -z "$env_name" ]]; then
                echo "‚ùå Error: Environment name required"
                echo "Usage: $(basename "$0") env $env_command <environment>"
                echo ""
                echo "Available environments:"
                if [[ -d "$setup_dir" ]]; then
                    ls -1 "$setup_dir" | grep -v '\.backup\.' | sed 's/\..*$//' | sort -u | sed 's/^/  /'
                else
                    echo "  (No environments found - run installer first)"
                fi
                exit 1
            fi
            
            # Handle VM name construction - if env_name already starts with dev-vm-, use it as-is
            local vm_name
            if [[ "$env_name" == dev-vm-* ]]; then
                vm_name="$env_name"
                # Extract the actual environment name for setup file lookup
                local actual_env_name="${env_name#dev-vm-}"
                local setup_file=$(find "$setup_dir" -type f -name "${actual_env_name}.*" 2>/dev/null | head -n 1)
            else
                vm_name="dev-vm-${env_name}"
                local setup_file=$(find "$setup_dir" -type f -name "${env_name}.*" 2>/dev/null | head -n 1)
            fi
            
            case "$env_command" in
                new)
                    echo "üöÄ Creating and provisioning '$env_name' using cloud-init..."
                    if [[ ! -f "$setup_file" ]]; then
                        echo "‚ùå Error: Setup file for '$env_name' not found in $setup_dir"
                        echo ""
                        echo "Available environments:"
                        if [[ -d "$setup_dir" ]]; then
                            ls -1 "$setup_dir" | grep -v '\.backup\.' | sed 's/\..*$//' | sort -u | sed 's/^/  /'
                        fi
                        exit 1
                    fi
                    
                    orb create --user-data "$setup_file" ubuntu "$vm_name"
                    echo "‚úÖ Environment '$env_name' is ready. Connecting..."
                    orb -m "$vm_name"
                    ;;
                up)
                    echo "üöÄ Starting environment '$env_name' and connecting..."
                    orb -m "$vm_name"
                    ;;
                down)
                    echo "üõë Stopping environment '$env_name'..."
                    orb stop "$vm_name"
                    echo "‚úÖ VM '$vm_name' stopped."
                    ;;
                status)
                    echo "üìä Status of environment '$env_name':"
                    echo "   VM Name: $vm_name"
                    
                    # Check if VM exists in orb list and get its status
                    if orb list | grep -q "^$vm_name"; then
                        local vm_info=$(orb list | grep "^$vm_name")
                        local state=$(echo "$vm_info" | awk '{print $2}')
                        local distro=$(echo "$vm_info" | awk '{print $3}')
                        local ip=$(echo "$vm_info" | awk '{print $NF}')
                        
                        case "$state" in
                            running)
                                echo "   Status: ‚úÖ Running"
                                echo "   IP: $ip"
                                echo "   Distro: $distro"
                                ;;
                            stopped)
                                echo "   Status: ‚è∏Ô∏è  Stopped"
                                echo "   Distro: $distro"
                                ;;
                            *)
                                echo "   Status: $state"
                                ;;
                        esac
                    else
                        echo "   Status: ‚ùå VM not found"
                        echo ""
                        echo "üí° Available VMs:"
                        orb list | grep "^dev-vm-" | awk '{print "   " $1 " (" $2 ")"}'
                        if ! orb list | grep -q "^dev-vm-"; then
                            echo "   (No development VMs found)"
                            echo ""
                            echo "üí° Create one with: $(basename "$0") env new docker-host"
                        fi
                    fi
                    ;;
                rm)
                    echo "üî• Deleting environment '$env_name'..."
                    if [[ "$AUTO_YES" == "true" ]]; then
                        echo "Auto-confirming deletion (--yes flag set)"
                        orb delete "$vm_name"
                        echo "‚úÖ VM '$vm_name' deleted."
                    else
                        read -p "Are you sure you want to permanently delete VM '$vm_name'? (y/N) " -n 1 -r
                        echo
                        if [[ $REPLY =~ ^[Yy]$ ]]; then
                            orb delete "$vm_name"
                            echo "‚úÖ VM '$vm_name' deleted."
                        else
                            echo "Deletion cancelled."
                        fi
                    fi
                    ;;
            esac
            ;;
        list|--help|-h|help)
            echo "Usage: $(basename "$0") env <command> [environment]"
            echo ""
            echo "Environment Management Commands:"
            echo "  new <env>        Create and provision a new environment VM"
            echo "  up <env>         Start an existing environment VM and connect"
            echo "  down <env>       Stop a running environment VM"
            echo "  status <env>     Show status of an environment VM"
            echo "  rm <env>         Delete an environment VM permanently"
            echo "  list             Show this help and available environments"
            echo ""
            echo "Available environments:"
            if [[ -d "$setup_dir" ]]; then
                ls -1 "$setup_dir" | grep -v '\.backup\.' | sed 's/\..*$//' | sort -u | sed 's/^/  /'
            else
                echo "  (No environments found - run installer first)"
            fi
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") env new docker-host    # Create Docker host VM"
            echo "  $(basename "$0") env up docker-host     # Start and connect to VM"
            echo "  $(basename "$0") env status docker-host # Check VM status"
            echo "  $(basename "$0") env down docker-host   # Stop VM to save resources"
            ;;
        *)
            echo "‚ùå Error: Unknown env command '$env_command'"
            echo "Use '$(basename "$0") env help' for usage information."
            exit 1
            ;;
    esac
}

function show_command_help() {
    local command="$1"
    case "$command" in
        new)
            echo "Usage: $(basename "$0") new <language> [--init]"
            echo ""
            echo "Create a Dockerfile from a language template."
            echo ""
            echo "Arguments:"
            echo "  <language>     Language template (python, node, golang, rust, java, php, bash)"
            echo "                 Optionally specify version: python-3.12, node-22, etc."
            echo ""
            echo "Options:"
            echo "  --init         Also create project scaffolding for the language"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") new python           # Latest Python template"
            echo "  $(basename "$0") new python-3.11      # Specific Python version"
            echo "  $(basename "$0") new node --init       # Node.js with package.json"
            echo "  $(basename "$0") new rust --init       # Rust with Cargo.toml"
            ;;
        config)
            echo "Usage: $(basename "$0") config [--edit|--init]"
            echo ""
            echo "Manage configuration files."
            echo ""
            echo "Options:"
            echo "  (no options)   Show current configuration"
            echo "  --edit         Edit global configuration in editor"
            echo "  --init         Create project-local configuration file"
            echo ""
            echo "Configuration Files:"
            echo "  Global:        ~/.dev-envs/config.yaml"
            echo "  Project-local: ./.devenv.yaml"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") config               # Show current config"
            echo "  $(basename "$0") config --edit        # Edit global config"
            echo "  $(basename "$0") config --init        # Create local config"
            ;;
        templates)
            echo "Usage: $(basename "$0") templates <action>"
            echo ""
            echo "Manage Dockerfile templates."
            echo ""
            echo "Actions:"
            echo "  update         Update all templates to latest versions"
            echo "  check          Check for available updates without applying"
            echo "  prune          Remove old/unused templates (smart cleanup)"
            echo "  cleanup [days] Remove templates unused for X days (default: 60)"
            echo "  stats          Show template statistics and usage information"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") templates update     # Update all templates"
            echo "  $(basename "$0") templates check      # Check for updates"
            echo "  $(basename "$0") templates prune      # Smart cleanup of old templates"
            echo "  $(basename "$0") templates cleanup 30 # Remove templates unused 30+ days"
            echo "  $(basename "$0") templates stats      # Show detailed statistics"
            ;;
        troubleshoot)
            echo "Troubleshooting Guide:"
            echo ""
            echo "Common Issues:"
            echo ""
            echo "1. Container fails to start:"
            echo "   ‚Ä¢ Check if OrbStack is running: 'orb list'"
            echo "   ‚Ä¢ Verify VM is accessible: '$(basename "$0") env status docker-host'"
            echo "   ‚Ä¢ Try rebuilding: '$(basename "$0") clean && $(basename "$0") build'"
            echo ""
            echo "2. Port forwarding not working:"
            echo "   ‚Ä¢ Ensure your app binds to 0.0.0.0, not localhost"
            echo "   ‚Ä¢ Check if port is already in use on host"
            echo "   ‚Ä¢ Verify framework-specific files exist (package.json, requirements.txt)"
            echo ""
            echo "3. SSH keys not working:"
            echo "   ‚Ä¢ Check SSH agent is running: 'ssh-add -l'"
            echo "   ‚Ä¢ Verify SSH keys exist in ~/.ssh/"
            echo "   ‚Ä¢ Try adding keys to agent: 'ssh-add ~/.ssh/id_rsa'"
            echo ""
            echo "4. Template creation fails:"
            echo "   ‚Ä¢ Check internet connection (templates fetch from Docker Hub)"
            echo "   ‚Ä¢ Try updating templates: '$(basename "$0") templates update'"
            echo "   ‚Ä¢ Verify language name: '$(basename "$0") list'"
            echo ""
            echo "5. Performance issues:"
            echo "   ‚Ä¢ Package caches are automatically mounted for faster installs"
            echo "   ‚Ä¢ Consider using .dockerignore to exclude large directories"
            echo "   ‚Ä¢ Check disk space: 'df -h'"
            echo ""
            echo "For more help, visit: https://github.com/mwing/isolated-dev"
            ;;
        env)
            echo "Usage: $(basename "$0") env <command> [environment]"
            echo ""
            echo "Manage OrbStack VMs for isolated development environments."
            echo ""
            echo "Commands:"
            echo "  new <env>        Create and provision new environment VM"
            echo "  up <env>         Start existing environment VM and connect"
            echo "  down <env>       Stop running environment VM"
            echo "  status <env>     Show environment VM status"
            echo "  rm <env>         Delete environment VM permanently"
            echo "  list             List available environments"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") env new docker-host    # One-time setup"
            echo "  $(basename "$0") env up docker-host     # Start & connect"
            echo "  $(basename "$0") env down docker-host   # Stop to save battery"
            echo "  $(basename "$0") env status docker-host # Check if running"
            echo ""
            echo "Note: Most users only need the 'docker-host' environment."
            ;;
        *)
            echo "No specific help available for command: $command"
            echo "Use --help for general usage information."
            ;;
    esac
}

function usage() {
    echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
    echo ""
    echo "A script to build and run isolated development containers using OrbStack VMs."
    echo ""
    echo "Commands:"
    echo "  run              Build and run the container (default)"
    echo "  shell            Open interactive bash shell in container"
    echo "  build            Build the container image only"
    echo "  clean            Remove existing container and image"
    echo ""
    echo "Environment Commands:"
    echo "  env <command>    Manage OrbStack VMs (new, up, down, status, rm)"
    echo "  env list         Show available environments and help"
    echo ""
    echo "Help Commands:"
    echo "  help             Show this help message"
    echo "  help <command>   Show help for specific command"
    echo "  troubleshoot     Show troubleshooting guide"
    echo ""
    echo "Template Commands:"
    echo "  new <language>       Create a Dockerfile from template"
    echo "  new <language> --init Create Dockerfile and project scaffolding"
    echo "  list                 List available language templates"
    echo "  templates update     Update templates to latest versions"
    echo "  templates check      Check for available template updates"
    echo "  templates prune      Remove old/unused templates automatically"
    echo "  templates cleanup    Remove templates unused for specified days"
    echo "  templates stats      Show template statistics and usage information"
    echo ""
    echo "Configuration Commands:"
    echo "  config               Show current configuration"
    echo "  config --edit        Edit global configuration file"
    echo "  config --init        Create project-local configuration"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -f, --file     Specify Dockerfile path (default: ./Dockerfile)"
    echo "  -t, --tag      Specify custom image tag"
    echo "  -n, --name     Specify custom container name"
    echo "  -y, --yes      Automatically answer 'yes' to all prompts (for automation)"
    echo ""
    echo "Enhanced Developer Experience:"
    echo "  ‚Ä¢ Automatic port forwarding detection (Node.js 3000, Python 8000, etc.)"
    echo "  ‚Ä¢ SSH key mounting for seamless git operations"
    echo "  ‚Ä¢ Git configuration sharing for consistent commits"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0") env new docker-host           # One-time VM setup"
    echo "  $(basename "$0")                              # Build and run with default Dockerfile"
    echo "  $(basename "$0") shell                        # Open interactive shell"
    echo "  $(basename "$0") new python                   # Create from Python template"
    echo "  $(basename "$0") new node-22 --init           # Create Node.js template with scaffolding"
    echo "  $(basename "$0") new python --yes             # Create template, auto-overwrite existing files"
    echo "  $(basename "$0") templates cleanup 30 --yes   # Remove old templates without prompting"
    echo "  $(basename "$0") env down docker-host         # Stop VM to save battery"
    echo "  $(basename "$0") list                         # Show available templates with versions"
    echo ""
    echo "Requirements:"
    echo "  - Dockerfile in current directory (or specified with -f)"
    echo "  - OrbStack VM '$VM_NAME' available"
    exit 0
}

function list_templates() {
    echo "Available Dockerfile templates:"
    if [[ -d "$TEMPLATES_DIR" ]]; then
        local templates_found=false
        
        # Create a simple formatted list
        printf "  %-12s %s\n" "Language" "Available Versions"
        printf "  %-12s %s\n" "--------" "------------------"
        
        # Process templates dynamically by discovering all languages
        local all_languages=$(ls "$TEMPLATES_DIR"/Dockerfile-* 2>/dev/null | grep -v '\.backup\.' | sed 's/.*Dockerfile-//' | sed 's/-.*$//' | sort -u)
        
        for lang in $all_languages; do
            local versions=""
            local version_count=0
            
            # Find all versions for this language
            for template_path in "$TEMPLATES_DIR/Dockerfile-$lang"-*; do
                if [[ -f "$template_path" ]] && [[ "$template_path" != *".backup."* ]]; then
                    local template_name=$(basename "$template_path" | sed 's/Dockerfile-//')
                    local version="${template_name#*-}"
                    
                    if [[ $version_count -eq 0 ]]; then
                        versions="$version"
                    else
                        versions="$versions, $version"
                    fi
                    ((version_count++))
                    found_templates=true
                    templates_found=true
                fi
            done
            
            # Display if we found templates for this language
            if [[ $version_count -gt 0 ]]; then
                printf "  %-12s %s\n" "$lang" "$versions"
            fi
        done
        
        if [[ "$templates_found" == false ]]; then
            echo "  (No templates found - run installer first)"
        fi
    else
        echo "  (Templates directory not found - run installer first)"
    fi
    exit 0
}

# ==============================================================================
# TEMPLATE VERSION DETECTION FUNCTIONS
# ==============================================================================

function get_latest_python_version() {
    # Fetch latest stable Python version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/python/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^3\.[0-9]+$' | \
        sort -V | tail -1 2>/dev/null)
    echo "${latest:-3.14}"
}

function get_latest_node_version() {
    # Fetch latest stable Node.js version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/node/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^[0-9]+$' | \
        sort -n | tail -1 2>/dev/null)
    echo "${latest:-22}"
}

function get_latest_golang_version() {
    # Fetch latest stable Go version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/golang/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^1\.[0-9]+$' | \
        sort -V | tail -1 2>/dev/null)
    echo "${latest:-1.23}"
}

function get_latest_rust_version() {
    # Fetch latest stable Rust version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/rust/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^1\.[0-9]+$' | \
        sort -V | tail -1 2>/dev/null)
    echo "${latest:-1.82}"
}

function check_template_updates() {
    echo "üîç Checking for latest template versions..."
    echo "‚è≥ Fetching current versions from official sources..."
    
    local templates_dir="$TEMPLATES_DIR"
    local missing_templates=()
    
    # Fetch current latest versions dynamically
    local python_latest="python-$(get_latest_python_version)"
    local node_latest="node-$(get_latest_node_version)"
    local golang_latest="golang-$(get_latest_golang_version)"
    local rust_latest="rust-$(get_latest_rust_version)"
    
    # Only check for languages where we can fetch latest versions
    local recommended=(
        "$python_latest"
        "$node_latest"
        "$golang_latest"
        "$rust_latest"
    )
    
    echo "üìã Latest versions detected:"
    for template in "${recommended[@]}"; do
        echo "  - $template"
    done
    echo ""
    
    # Check which templates are missing
    for template in "${recommended[@]}"; do
        if [[ ! -f "$templates_dir/Dockerfile-$template" ]]; then
            missing_templates+=("$template")
        fi
    done
    
    if [[ ${#missing_templates[@]} -eq 0 ]]; then
        echo "‚úÖ All latest template versions are available!"
    else
        echo "üì¶ Missing latest templates:"
        for template in "${missing_templates[@]}"; do
            echo "  - $template"
        done
        echo ""
        echo "üí° Run 'dev templates update' to create missing versions."
    fi
}

function update_templates() {
    echo "üîÑ Creating missing template versions..."
    echo "‚è≥ Fetching latest versions..."
    echo ""
    
    local templates_dir="$TEMPLATES_DIR"
    local created_count=0
    
    # Get latest versions dynamically
    local python_version=$(get_latest_python_version)
    local node_version=$(get_latest_node_version)
    local golang_version=$(get_latest_golang_version)
    local rust_version=$(get_latest_rust_version)
    
    # Python latest (if missing)
    if [[ ! -f "$templates_dir/Dockerfile-python-$python_version" ]]; then
        echo "üì¶ Adding Python $python_version template..."
        if create_dockerfile_from_skeleton "python" "$python_version" "$templates_dir/Dockerfile-python-$python_version"; then
            echo "   ‚úÖ Python $python_version template created"
            ((created_count++))
        else
            echo "   ‚ùå Failed to create Python $python_version template"
        fi
    fi
    
    # Node.js latest (if missing)  
    if [[ ! -f "$templates_dir/Dockerfile-node-$node_version" ]]; then
        echo "üì¶ Adding Node.js $node_version template..."
        if create_dockerfile_from_skeleton "node" "$node_version" "$templates_dir/Dockerfile-node-$node_version"; then
            echo "   ‚úÖ Node.js $node_version template created"
            ((created_count++))
        else
            echo "   ‚ùå Failed to create Node.js $node_version template"
        fi
    fi
    
    # Golang latest (if missing)
    if [[ ! -f "$templates_dir/Dockerfile-golang-$golang_version" ]]; then
        echo "üì¶ Adding Go $golang_version template..."
        if create_dockerfile_from_skeleton "golang" "$golang_version" "$templates_dir/Dockerfile-golang-$golang_version"; then
            echo "   ‚úÖ Go $golang_version template created"
            ((created_count++))
        else
            echo "   ‚ùå Failed to create Go $golang_version template"
        fi
    fi
    
    # Rust latest (if missing)
    if [[ ! -f "$templates_dir/Dockerfile-rust-$rust_version" ]]; then
        echo "üì¶ Adding Rust $rust_version template..."
        if create_dockerfile_from_skeleton "rust" "$rust_version" "$templates_dir/Dockerfile-rust-$rust_version"; then
            echo "   ‚úÖ Rust $rust_version template created"
            ((created_count++))
        else
            echo "   ‚ùå Failed to create Rust $rust_version template"
        fi
    fi
    
    echo ""
    if [[ $created_count -gt 0 ]]; then
        echo "‚úÖ Template updates completed! Created $created_count new templates."
    else
        echo "‚úÖ All templates were already up to date."
    fi
    echo ""
    echo "üí° Tip: Use 'dev list' to see all available templates"
}

# ==============================================================================
# TEMPLATE CLEANUP FUNCTIONS
# ==============================================================================

function prune_old_templates() {
    echo "üßπ Analyzing template usage and removing old versions..."
    echo ""
    
    local templates_dir="$TEMPLATES_DIR"
    local usage_file="$HOME/.dev-envs/template_usage.log"
    local current_date=$(date +%s)
    local days_threshold=30
    local threshold_date=$((current_date - days_threshold * 86400))
    
    # Create usage tracking file if it doesn't exist
    if [[ ! -f "$usage_file" ]]; then
        touch "$usage_file"
        echo "üìù Created template usage tracking file"
    fi
    
    # Find the most recently created template for each language (these are "latest")
    local temp_file=$(mktemp)
    
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        local file_time=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
        
        echo "$language:$template_name:$file_time" >> "$temp_file"
    done
    
    echo "üîí Protected templates (latest per language):"
    # Find latest template for each language
    for language in $(cut -d: -f1 "$temp_file" | sort -u); do
        local latest=$(grep "^$language:" "$temp_file" | sort -t: -k3 -nr | head -1 | cut -d: -f2)
        echo "   ‚úÖ $latest (latest $language)"
    done
    echo ""
    
    local removed_count=0
    local total_templates=0
    local kept_count=0
    
    # Analyze each template
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        ((total_templates++))
        
        # Always keep the latest template for each language
        local latest=$(grep "^$language:" "$temp_file" | sort -t: -k3 -nr | head -1 | cut -d: -f2)
        if [[ "$latest" == "$template_name" ]]; then
            echo "üîí Keeping latest: $template_name"
            ((kept_count++))
            continue
        fi
        
        # Check if template has been used recently
        local last_used=$(grep "^$template_name:" "$usage_file" 2>/dev/null | tail -1 | cut -d: -f2)
        
        if [[ -z "$last_used" ]]; then
            # Never used, check file age instead
            local file_age=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
            if [[ $file_age -lt $threshold_date ]]; then
                echo "üóëÔ∏è  Removing unused: $template_name (created >$days_threshold days ago, never used)"
                rm "$template_file"
                ((removed_count++))
            else
                echo "‚è≥ Keeping recent: $template_name (created recently, not yet used)"
                ((kept_count++))
            fi
        elif [[ $last_used -lt $threshold_date ]]; then
            echo "üóëÔ∏è  Removing old: $template_name (last used >$days_threshold days ago)"
            rm "$template_file"
            ((removed_count++))
        else
            echo "‚úÖ Keeping active: $template_name (used recently)"
            ((kept_count++))
        fi
    done
    
    local language_count=$(cut -d: -f1 "$temp_file" | sort -u | wc -l)
    rm "$temp_file"
    
    echo ""
    echo "üìä Pruning Summary:"
    echo "   Total templates: $total_templates"
    echo "   Removed: $removed_count"
    echo "   Kept: $kept_count"
    echo "   Languages with templates: $language_count"
    
    if [[ $removed_count -gt 0 ]]; then
        echo ""
        echo "‚úÖ Template cleanup complete! Freed up space by removing $removed_count old templates."
        echo "üí° Run 'dev templates update' to recreate current versions if needed."
    else
        echo ""
        echo "‚ú® No templates needed removal - all are recent, active, or latest versions!"
    fi
}

function cleanup_unused_templates() {
    local days="${1:-60}"
    echo "üßπ Cleaning up templates unused for $days+ days..."
    echo ""
    
    local templates_dir="$TEMPLATES_DIR"
    local usage_file="$HOME/.dev-envs/template_usage.log"
    local current_date=$(date +%s)
    local threshold_date=$((current_date - days * 86400))
    
    if [[ ! -f "$usage_file" ]]; then
        echo "üìù No usage tracking file found - analyzing by file age instead"
        echo ""
    fi
    
    # Find latest templates per language to protect them
    local temp_file=$(mktemp)
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        local file_time=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
        
        echo "$language:$template_name:$file_time" >> "$temp_file"
    done
    
    local removed_count=0
    
    # Show what would be removed
    echo "üîç Templates that would be removed:"
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        local should_remove=false
        
        # Never remove the latest template for each language
        local latest_for_lang=$(grep "^$language:" "$temp_file" | sort -t: -k3 -nr | head -1 | cut -d: -f2)
        if [[ "$latest_for_lang" == "$template_name" ]]; then
            continue
        fi
        
        if [[ -f "$usage_file" ]]; then
            local last_used=$(grep "^$template_name:" "$usage_file" 2>/dev/null | tail -1 | cut -d: -f2)
            if [[ -n "$last_used" && $last_used -lt $threshold_date ]]; then
                should_remove=true
            elif [[ -z "$last_used" ]]; then
                local file_age=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
                if [[ $file_age -lt $threshold_date ]]; then
                    should_remove=true
                fi
            fi
        else
            local file_age=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
            if [[ $file_age -lt $threshold_date ]]; then
                should_remove=true
            fi
        fi
        
        if [[ "$should_remove" == "true" ]]; then
            local latest=$(grep "^$language:" "$temp_file" | sort -t: -k3 -nr | head -1 | cut -d: -f2)
            echo "   üóëÔ∏è  $template_name (keeping latest: $latest)"
            ((removed_count++))
        fi
    done
    
    if [[ $removed_count -eq 0 ]]; then
        echo "   ‚ú® No old templates need cleanup!"
        echo "   üí° All templates are either recent, in use, or the latest version of their language."
        return
    fi
    
    echo ""
    echo "‚ö†Ô∏è  This will remove $removed_count old template version(s)."
    echo "   Latest templates for each language will be preserved."
    if [[ "$AUTO_YES" == "true" ]]; then
        echo "Auto-confirming cleanup (--yes flag set)"
    else
        read -p "Continue? (y/N) " -n 1 -r
        echo
        
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cleanup cancelled."
            return
        fi
    fi
    
    # Actually remove them
    removed_count=0
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        local should_remove=false
        
        # Never remove the latest template for each language
        local latest_for_lang=$(grep "^$language:" "$temp_file" | sort -t: -k3 -nr | head -1 | cut -d: -f2)
        if [[ "$latest_for_lang" == "$template_name" ]]; then
            continue
        fi
        
        if [[ -f "$usage_file" ]]; then
            local last_used=$(grep "^$template_name:" "$usage_file" 2>/dev/null | tail -1 | cut -d: -f2)
            if [[ -n "$last_used" && $last_used -lt $threshold_date ]]; then
                should_remove=true
            elif [[ -z "$last_used" ]]; then
                local file_age=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
                if [[ $file_age -lt $threshold_date ]]; then
                    should_remove=true
                fi
            fi
        else
            local file_age=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
            if [[ $file_age -lt $threshold_date ]]; then
                should_remove=true
            fi
        fi
        
        if [[ "$should_remove" == "true" ]]; then
            echo "üóëÔ∏è  Removing: $template_name"
            rm "$template_file"
            ((removed_count++))
        fi
    done
    
    echo ""
    echo "‚úÖ Cleanup complete! Removed $removed_count old template versions."
    echo "üí° Latest version of each language preserved for future use."
}

function show_template_stats() {
    echo "üìä Template Statistics"
    echo ""
    
    local templates_dir="$TEMPLATES_DIR"
    local usage_file="$HOME/.dev-envs/template_usage.log"
    
    if [[ ! -d "$templates_dir" ]]; then
        echo "‚ùå Templates directory not found: $templates_dir"
        return 1
    fi
    
    # Get template information using a simpler approach
    local total_templates=0
    local temp_file=$(mktemp)
    
    # Create a temporary file with language data
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        local file_time=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
        
        echo "$language:$template_name:$file_time" >> "$temp_file"
        ((total_templates++))
    done
    
    echo "üì¶ Templates by Language:"
    printf "   %-12s %-8s %s\n" "Language" "Count" "Latest Version"
    printf "   %-12s %-8s %s\n" "--------" "-----" "--------------"
    
    # Process languages and show counts/latest
    for language in $(cut -d: -f1 "$temp_file" | sort -u); do
        local count=$(grep "^$language:" "$temp_file" | wc -l)
        local latest=$(grep "^$language:" "$temp_file" | sort -t: -k3 -nr | head -1 | cut -d: -f2)
        printf "   %-12s %-8s %s\n" "$language" "$count" "$latest"
    done
    
    rm "$temp_file"
    
    echo ""
    echo "üìà Usage Statistics:"
    if [[ -f "$usage_file" ]]; then
        echo "   Total usage records: $(wc -l < "$usage_file" 2>/dev/null || echo 0)"
        
        # Show most used templates
        if [[ -s "$usage_file" ]]; then
            echo ""
            echo "   üî• Most Used Templates (last 30 days):"
            local thirty_days_ago=$(($(date +%s) - 30 * 86400))
            
            awk -F: -v threshold="$thirty_days_ago" '
                $2 >= threshold { count[$1]++ }
                END {
                    for (template in count) {
                        print count[template], template
                    }
                }
            ' "$usage_file" | sort -nr | head -5 | while read count template; do
                printf "      %-3s uses: %s\n" "$count" "$template"
            done
        fi
    else
        echo "   No usage tracking data available"
        echo "   (Usage tracking starts when templates are first used)"
    fi
    
    echo ""
    echo "üíæ Storage Information:"
    local total_size=0
    if command -v du >/dev/null 2>&1; then
        total_size=$(du -sh "$templates_dir" 2>/dev/null | cut -f1 || echo "Unknown")
        echo "   Total template storage: $total_size"
    fi
    echo "   Total templates: $total_templates"
    echo "   Languages supported: ${#lang_counts[@]}"
    
    # Show potential cleanup opportunities
    echo ""
    echo "üßπ Cleanup Opportunities:"
    local old_count=0
    local unused_count=0
    local thirty_days_ago=$(($(date +%s) - 30 * 86400))
    
    for template_file in "$templates_dir"/Dockerfile-*; do
        [[ -f "$template_file" ]] || continue
        
        local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
        local language=$(echo "$template_name" | sed 's/-.*$//')
        local file_age=$(stat -f %B "$template_file" 2>/dev/null || stat -c %Y "$template_file" 2>/dev/null || echo 0)
        
        # Skip if it's the latest for this language
        if [[ "${lang_latest[$language]}" == "$template_name" ]]; then
            continue
        fi
        
        # Check if old
        if [[ $file_age -lt $thirty_days_ago ]]; then
            ((old_count++))
        fi
        
        # Check if unused
        if [[ -f "$usage_file" ]]; then
            if ! grep -q "^$template_name:" "$usage_file"; then
                ((unused_count++))
            fi
        fi
    done
    
    if [[ $old_count -gt 0 || $unused_count -gt 0 ]]; then
        [[ $old_count -gt 0 ]] && echo "   üìÖ $old_count templates older than 30 days (excluding latest versions)"
        [[ $unused_count -gt 0 ]] && echo "   üö´ $unused_count templates never used"
        echo ""
        echo "üí° Run 'dev templates prune' for smart cleanup"
    else
        echo "   ‚ú® All templates are recent or actively used!"
    fi
}

function track_template_usage() {
    local template_name="$1"
    local usage_file="$HOME/.dev-envs/template_usage.log"
    local timestamp=$(date +%s)
    
    # Create usage directory if it doesn't exist
    mkdir -p "$(dirname "$usage_file")"
    
    # Log usage
    echo "$template_name:$timestamp" >> "$usage_file"
    
    # Keep only last 100 entries per template to prevent log bloat
    local temp_file=$(mktemp)
    awk -F: -v template="$template_name" '
        $1 == template { entries[template]++; if(entries[template] <= 100) print }
        $1 != template { print }
    ' "$usage_file" > "$temp_file"
    mv "$temp_file" "$usage_file"
}

# ==============================================================================
# PROJECT SCAFFOLDING FUNCTIONS
# ==============================================================================

function init_project_scaffolding() {
    local language="$1"
    local base_lang="${language%%-*}"  # Extract base language (python, node, etc.)
    
    case "$base_lang" in
        python)
            echo "   -> Creating Python project structure..."
            
            local project_name=$(basename "$(pwd)")
            if copy_scaffolding_files "python" "$project_name"; then
                echo "   -> Created: requirements.txt, main.py, .gitignore"
            else
                echo "   -> ‚ùå Failed to create Python project structure"
            fi
            ;;
            
        node)
            echo "   -> Creating Node.js project structure..."
            
            local project_name=$(basename "$(pwd)")
            if copy_scaffolding_files "node" "$project_name"; then
                echo "   -> Created: package.json, index.js, .gitignore"
            else
                echo "   -> ‚ùå Failed to create Node.js project structure"
            fi
            ;;
            
        golang)
            echo "   -> Creating Go project structure..."
            
            local project_name=$(basename "$(pwd)")
            local go_version=$(get_latest_golang_version)
            
            if copy_scaffolding_files "golang" "$project_name" "$go_version"; then
                echo "   -> Created: go.mod, main.go, .gitignore"
            else
                echo "   -> ‚ùå Failed to create Go project structure"
            fi
            ;;
            
        rust)
            echo "   -> Creating Rust project structure..."
            local project_name=$(basename "$(pwd)")
            if copy_scaffolding_files "rust" "$project_name"; then
                mkdir -p src
                cp "$SCAFFOLDING_SKELETONS/rust/main.rs" src/main.rs
                echo "   -> Created: Cargo.toml, src/main.rs, .gitignore"
            else
                echo "   -> ‚ùå Failed to create Rust project structure"
            fi
            ;;
            
        java)
            echo "   -> Creating Java project structure..."
            local project_name=$(basename "$(pwd)")
            if copy_scaffolding_files "java" "$project_name"; then
                mkdir -p src/main/java/com/example
                cp "$SCAFFOLDING_SKELETONS/java/Main.java" src/main/java/com/example/Main.java
                echo "   -> Created: pom.xml, src/main/java/com/example/Main.java, .gitignore"
            else
                echo "   -> ‚ùå Failed to create Java project structure"
            fi
            ;;
            
        php)
            echo "   -> Creating PHP project structure..."
            local project_name=$(basename "$(pwd)")
            if copy_scaffolding_files "php" "$project_name"; then
                mkdir -p src
                cp "$SCAFFOLDING_SKELETONS/php/index.php" index.php
                echo "   -> Created: composer.json, index.php, src/, .gitignore"
            else
                echo "   -> ‚ùå Failed to create PHP project structure"
            fi
            ;;
            
        bash)
            echo "   -> Creating Bash project structure..."
            local project_name=$(basename "$(pwd)")
            if copy_scaffolding_files "bash" "$project_name"; then
                cp "$SCAFFOLDING_SKELETONS/bash/main.sh" "$project_name.sh"
                chmod +x "$project_name.sh"
                echo "   -> Created: $project_name.sh, .gitignore"
            else
                echo "   -> ‚ùå Failed to create Bash project structure"
            fi
            ;;
            
        *)
            echo "   -> No specific scaffolding available for $base_lang"
            echo "   -> Created basic .gitignore"
            if [[ -f "$SCAFFOLDING_SKELETONS/basic/.gitignore" ]]; then
                cp "$SCAFFOLDING_SKELETONS/basic/.gitignore" .gitignore
            else
                echo "   -> ‚ùå Basic .gitignore skeleton not found"
            fi
            ;;
    esac
}

# ==============================================================================
# DEVELOPER EXPERIENCE FUNCTIONS
# ==============================================================================

function detect_common_ports() {
    local ports=()
    
    # Check for common development files and add corresponding ports
    if [[ -f "package.json" ]]; then
        # Node.js common ports
        ports+=(3000 8080 5000 4000)
        
        # Check for specific frameworks in package.json
        if grep -q "next" package.json 2>/dev/null; then
            ports+=(3000)
        fi
        if grep -q "react-scripts" package.json 2>/dev/null; then
            ports+=(3000)
        fi
        if grep -q "vite" package.json 2>/dev/null; then
            ports+=(5173)
        fi
    fi
    
    if [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
        # Python common ports
        ports+=(8000 5000 8080)
        
        # Check for specific frameworks
        if grep -q "flask" requirements.txt 2>/dev/null || grep -q "Flask" requirements.txt 2>/dev/null; then
            ports+=(5000)
        fi
        if grep -q "django" requirements.txt 2>/dev/null || grep -q "Django" requirements.txt 2>/dev/null; then
            ports+=(8000)
        fi
        if grep -q "fastapi" requirements.txt 2>/dev/null || grep -q "FastAPI" requirements.txt 2>/dev/null; then
            ports+=(8000)
        fi
    fi
    
    if [[ -f "go.mod" ]]; then
        # Go common ports
        ports+=(8080 8000 3000)
    fi
    
    if [[ -f "Cargo.toml" ]]; then
        # Rust common ports
        ports+=(8080 3000 8000)
    fi
    
    if [[ -f "composer.json" ]]; then
        # PHP common ports
        ports+=(8080 8000 80)
    fi
    
    if [[ -f "pom.xml" ]] || [[ -f "build.gradle" ]]; then
        # Java common ports
        ports+=(8080 8000 9000)
    fi
    
    # Remove duplicates and return
    printf '%s\n' "${ports[@]}" | sort -nu | tr '\n' ' '
}

function get_ssh_key_mounts() {
    local ssh_mounts=""
    
    # Mount SSH keys if they exist
    if [[ -d "$HOME/.ssh" ]]; then
        ssh_mounts="-v $HOME/.ssh:/root/.ssh:ro"
    fi
    
    echo "$ssh_mounts"
}

function get_common_volume_mounts() {
    local volumes=""
    
    # Always mount the current directory
    volumes="-v $(pwd):/workspace"
    
    # Mount git configuration if it exists
    if [[ -f "$HOME/.gitconfig" ]]; then
        volumes="$volumes -v $HOME/.gitconfig:/tmp/.gitconfig:ro"
    fi
    
    # Mount Docker socket for Docker-in-Docker development
    if [[ -S "/var/run/docker.sock" ]]; then
        volumes="$volumes -v /var/run/docker.sock:/var/run/docker.sock"
    fi
    
    echo "$volumes"
}

function build_port_forwards() {
    local ports=($(detect_common_ports))
    local port_args=""
    
    if [[ ${#ports[@]} -gt 0 ]]; then
        echo "üîå Detected common development ports: ${ports[*]}"
        for port in "${ports[@]}"; do
            port_args="$port_args -p $port:$port"
        done
    fi
    
    echo "$port_args"
}

# ==============================================================================
# COMMAND HANDLERS
# ==============================================================================

function handle_config_command() {
    local subcommand="$1"
    
    # Load configuration before processing commands
    load_config
    
    case "$subcommand" in
        --edit)
            create_default_config
            if command -v code >/dev/null 2>&1; then
                echo "üìù Opening config in VS Code..."
                code "$GLOBAL_CONFIG"
            elif command -v vim >/dev/null 2>&1; then
                echo "üìù Opening config in vim..."
                vim "$GLOBAL_CONFIG"
            else
                echo "üìù Edit your config file: $GLOBAL_CONFIG"
            fi
            exit 0
            ;;
        --init)
            if [[ -f "$PROJECT_CONFIG" ]]; then
                echo "‚ö†Ô∏è  Project config already exists: $PROJECT_CONFIG"
                if [[ "$AUTO_YES" == "true" ]]; then
                    echo "Auto-confirming overwrite (--yes flag set)"
                else
                    echo -n "Do you want to overwrite it? (y/N): "
                    read -r response
                    if [[ ! "$response" =~ ^[Yy]$ ]]; then
                        echo "Operation cancelled."
                        exit 0
                    fi
                fi
            fi
            
            local project_name=$(basename "$(pwd)")
            if [[ -f "$SCAFFOLDING_SKELETONS/basic/project-config.yaml" ]]; then
                sed "s/{{PROJECT_NAME}}/$project_name/g" "$SCAFFOLDING_SKELETONS/basic/project-config.yaml" > "$PROJECT_CONFIG"
            else
                echo "‚ùå Error: Project config skeleton not found"
                exit 1
            fi
            echo "‚úÖ Created project config: $PROJECT_CONFIG"
            echo "   Edit this file to customize settings for this project."
            exit 0
            ;;
        *)
            # Show current configuration
            create_default_config
            
            echo "üìã Current Configuration:"
            echo "  Global config: $GLOBAL_CONFIG"
            if [[ -f "$PROJECT_CONFIG" ]]; then
                echo "  Project config: $PROJECT_CONFIG (active)"
            else
                echo "  Project config: none"
            fi
            echo ""
            echo "  VM Name: $VM_NAME"
            echo "  Default Template: ${DEFAULT_TEMPLATE:-"(prompt for selection)"}"
            echo "  Auto Start VM: $AUTO_START_VM"
            echo "  Container Prefix: $CONTAINER_PREFIX"
            echo ""
            echo "Commands:"
            echo "  dev config --edit    Edit global configuration"
            echo "  dev config --init    Create project configuration"
            exit 0
            ;;
    esac
}

function create_from_template() {
    local language="$1"
    local init_project="${2:-false}"
    local template_file=""
    local target_file="./Dockerfile"
    
    if [[ ! -d "$TEMPLATES_DIR" ]]; then
        echo "‚ùå Error: Templates directory not found at $TEMPLATES_DIR"
        echo "Please run the installer first."
        exit 1
    fi
    
    # Smart template matching logic
    # 1. Try exact match first (e.g., "python-3.13" -> "Dockerfile-python-3.13")
    if [[ -f "$TEMPLATES_DIR/Dockerfile-$language" ]]; then
        template_file="$TEMPLATES_DIR/Dockerfile-$language"
        echo "üìã Using template: $language"
    else
        # 2. Look for versioned templates that start with the language name
        local matching_templates=($(find "$TEMPLATES_DIR" -name "Dockerfile-${language}-*" -type f | grep -v '\.backup\.' 2>/dev/null))
        
        if [[ ${#matching_templates[@]} -eq 1 ]]; then
            # Found exactly one versioned template for this language
            template_file="${matching_templates[0]}"
            local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
            echo "üìã Using template: $template_name"
        elif [[ ${#matching_templates[@]} -gt 1 ]]; then
            # Multiple versions available - check if we have a default configured
            if [[ -n "$DEFAULT_TEMPLATE" ]]; then
                # Check if the default template matches this language
                if [[ "$DEFAULT_TEMPLATE" == "$language"* ]]; then
                    for template in "${matching_templates[@]}"; do
                        local template_name=$(basename "$template" | sed 's/Dockerfile-//')
                        if [[ "$template_name" == "$DEFAULT_TEMPLATE" ]]; then
                            template_file="$template"
                            echo "üìã Using default template: $template_name"
                            break
                        fi
                    done
                fi
            fi
            
            # If no default found, ask user to be specific
            if [[ -z "$template_file" ]]; then
                echo "‚ùå Error: Multiple versions available for '$language'."
                echo "Please specify the version you want:"
                echo ""
                printf "  %-20s %s\n" "Template Name" "Usage"
                printf "  %-20s %s\n" "-------------" "-----"
                for template in "${matching_templates[@]}"; do
                    local template_name=$(basename "$template" | sed 's/Dockerfile-//')
                    printf "  %-20s %s\n" "$template_name" "dev new $template_name"
                done
                echo ""
                echo "Or run 'dev list' to see all available options."
                echo "Tip: Set a default with 'dev config --edit' to skip this prompt."
                exit 1
            fi
        else
            # No templates found for this language
            echo "‚ùå Error: No template found for '$language'."
            echo "Available templates:"
            list_templates
            exit 1
        fi
    fi
    
    if [[ -f "$target_file" ]]; then
        echo "‚ö†Ô∏è  Warning: Dockerfile already exists in current directory."
        if [[ "$AUTO_YES" == "true" ]]; then
            echo "Auto-confirming overwrite (--yes flag set)"
        else
            echo -n "Do you want to overwrite it? (y/N): "
            read -r response
            if [[ ! "$response" =~ ^[Yy]$ ]]; then
                echo "Operation cancelled."
                exit 0
            fi
        fi
    fi
    
    cp "$template_file" "$target_file" || {
        echo "‚ùå Error: Failed to copy template"
        exit 1
    }
    
    # Track template usage for cleanup purposes
    local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
    track_template_usage "$template_name"
    
    echo "‚úÖ Created Dockerfile from $language template"
    
    # Initialize project scaffolding if requested
    if [[ "$init_project" == "true" ]]; then
        echo "üèóÔ∏è  Initializing project scaffolding..."
        init_project_scaffolding "$language"
    fi
    
    echo "You can now run 'dev' to build and run your container."
    exit 0
}

# ==============================================================================
# MAIN EXECUTION
# ==============================================================================

# Initialize default values
DOCKERFILE="Dockerfile"
COMMAND="run"
CUSTOM_TAG=""
CUSTOM_NAME=""
AUTO_YES=false

# Process command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        list)
            list_templates
            ;;
        templates)
            case "$2" in
                update)
                    update_templates
                    exit 0
                    ;;
                check)
                    check_template_updates
                    exit 0
                    ;;
                prune)
                    prune_old_templates
                    exit 0
                    ;;
                cleanup)
                    # Handle optional days parameter and --yes flag
                    days="$3"
                    shift 3  # Remove 'templates', 'cleanup', and days
                    while [[ $# -gt 0 ]]; do
                        case $1 in
                            --yes|-y)
                                AUTO_YES=true
                                shift
                                ;;
                            *)
                                echo "‚ùå Error: Unknown flag for 'templates cleanup': $1"
                                exit 1
                                ;;
                        esac
                    done
                    cleanup_unused_templates "$days"
                    exit 0
                    ;;
                stats)
                    show_template_stats
                    exit 0
                    ;;
                *)
                    echo "‚ùå Error: Unknown templates subcommand '$2'"
                    echo "Available: update, check, prune, cleanup, stats"
                    exit 1
                    ;;
            esac
            ;;
        config)
            shift 1  # Remove 'config'
            # Parse config subcommand and flags
            subcommand="$1"
            shift 1
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --yes|-y)
                        AUTO_YES=true
                        shift
                        ;;
                    *)
                        echo "‚ùå Error: Unknown flag for 'config' command: $1"
                        exit 1
                        ;;
                esac
            done
            handle_config_command "$subcommand"
            ;;
        new)
            if [[ -z "$2" ]]; then
                echo "‚ùå Error: new requires a language argument"
                echo "Use 'dev list' to see available options."
                exit 1
            fi
            # Parse flags for new command
            init_project=false
            language="$2"
            shift 2  # Remove 'new' and language from args
            
            # Process remaining arguments for flags
            while [[ $# -gt 0 ]]; do
                case $1 in
                    --init)
                        init_project=true
                        shift
                        ;;
                    --yes|-y)
                        AUTO_YES=true
                        shift
                        ;;
                    *)
                        echo "‚ùå Error: Unknown flag for 'new' command: $1"
                        exit 1
                        ;;
                esac
            done
            
            create_from_template "$language" "$init_project"
            ;;
        -f|--file)
            DOCKERFILE="$2"
            shift 2
            ;;
        -t|--tag)
            CUSTOM_TAG="$2"
            shift 2
            ;;
        -n|--name)
            CUSTOM_NAME="$2"
            shift 2
            ;;
        -y|--yes)
            AUTO_YES=true
            shift
            ;;
        run|build|clean|shell)
            COMMAND="$1"
            shift
            ;;
        help)
            if [[ -n "$2" ]]; then
                show_command_help "$2"
            else
                usage
                echo ""
                echo "Available help topics:"
                echo "  $(basename "$0") help new           # Template creation help"
                echo "  $(basename "$0") help config        # Configuration help"
                echo "  $(basename "$0") help templates     # Template management help"
                echo "  $(basename "$0") help env           # Environment management help"
                echo "  $(basename "$0") troubleshoot       # Troubleshooting guide"
            fi
            exit 0
            ;;
        troubleshoot)
            show_command_help "troubleshoot"
            exit 0
            ;;
        env)
            # Pass all remaining arguments to handle_env_command
            shift 1  # Remove 'env'
            handle_env_command "$@"
            exit 0
            ;;
        *)
            echo "‚ùå Error: Unknown option '$1'"
            echo "Available commands: run, shell, build, clean, new, list, config, templates, env, help, troubleshoot"
            echo "Use --help for usage information or 'help <command>' for command-specific help."
            exit 1
            ;;
    esac
done

# --- Load Configuration ---
load_config

# --- Validate Requirements ---
if [[ "$COMMAND" != "clean" ]]; then
    if [ ! -f "$DOCKERFILE" ]; then
        echo "‚ùå Error: No Dockerfile found at '$DOCKERFILE'"
        echo ""
        echo "üí° Suggestions:"
        echo "   ‚Ä¢ Create from template: '$(basename "$0") new <language>'"
        echo "   ‚Ä¢ Use different file: '$(basename "$0") -f /path/to/Dockerfile'"
        echo "   ‚Ä¢ See available templates: '$(basename "$0") list'"
        echo "   ‚Ä¢ Get help: '$(basename "$0") help new'"
        exit 1
    fi
fi

# --- Generate Names ---
PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
IMAGE_NAME="${CUSTOM_TAG:-${CONTAINER_PREFIX}-img-${PROJECT_NAME}}"
CONTAINER_NAME="${CUSTOM_NAME:-${CONTAINER_PREFIX}-ctn-${PROJECT_NAME}}"

# --- Helper Functions for Container Operations ---
ensure_vm_running() {
    if ! orb status "$VM_NAME" 2>/dev/null | grep -q "running"; then
        if [[ "$AUTO_START_VM" == "true" ]]; then
            echo "   -> Starting VM '$VM_NAME'..."
            orb start "$VM_NAME"
        else
            echo "‚ùå Error: VM '$VM_NAME' is not running"
            echo "   Start it manually with: dev env up docker-host"
            echo "   Or set auto_start_vm=true in your config"
            exit 1
        fi
    fi
}

build_image() {
    echo "   -> Building Docker image '$IMAGE_NAME'..."
    orb -m "$VM_NAME" sudo docker build -f "$DOCKERFILE" -t "$IMAGE_NAME" .
}

cleanup_existing_container() {
    if orb -m "$VM_NAME" sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "   -> Stopping existing container..."
        orb -m "$VM_NAME" sudo docker stop "$CONTAINER_NAME" >/dev/null 2>&1
        orb -m "$VM_NAME" sudo docker rm "$CONTAINER_NAME" >/dev/null 2>&1
    fi
}

# --- Main Logic ---
case $COMMAND in
    run)
        echo "üöÄ Preparing isolated container for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        cleanup_existing_container
        
        # Build enhanced container options
        volume_mounts=$(get_common_volume_mounts)
        ssh_mounts=$(get_ssh_key_mounts)
        port_forwards=$(build_port_forwards)
        
        echo "üîß Enhanced developer experience:"
        if [[ -n "$port_forwards" ]]; then
            echo "   -> Port forwarding enabled for detected services"
        fi
        if [[ -n "$ssh_mounts" ]]; then
            echo "   -> SSH keys mounted for git authentication"
        fi
        echo "   -> Git configuration mounted for consistent commits"
        echo ""
        echo "‚úÖ Connecting to container. Your project folder is at '/workspace'."
        
        orb -m "$VM_NAME" sudo docker run -it --rm \
            $volume_mounts \
            $ssh_mounts \
            $port_forwards \
            --name "$CONTAINER_NAME" \
            "$IMAGE_NAME"
        ;;
    shell)
        echo "üêö Opening interactive shell in '$PROJECT_NAME' container..."
        ensure_vm_running
        build_image
        cleanup_existing_container
        
        # Build enhanced container options
        volume_mounts=$(get_common_volume_mounts)
        ssh_mounts=$(get_ssh_key_mounts)
        port_forwards=$(build_port_forwards)
        
        echo "üîß Enhanced developer experience:"
        if [[ -n "$port_forwards" ]]; then
            echo "   -> Port forwarding enabled for detected services"
        fi
        if [[ -n "$ssh_mounts" ]]; then
            echo "   -> SSH keys mounted for git authentication"
        fi
        echo "   -> Git configuration mounted for consistent commits"
        echo ""
        echo "‚úÖ Container ready. Your project folder is at '/workspace'."
        
        orb -m "$VM_NAME" sudo docker run -it --rm \
            $volume_mounts \
            $ssh_mounts \
            $port_forwards \
            --name "$CONTAINER_NAME" \
            "$IMAGE_NAME" bash
        ;;
    build)
        echo "üî® Building image for '$PROJECT_NAME'..."
        build_image
        echo "‚úÖ Image built successfully"
        ;;
        
    build)
        echo "üî® Building container image for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        echo "‚úÖ Image '$IMAGE_NAME' built successfully."
        ;;
        
    clean)
        echo "üßπ Cleaning up containers and images for '$PROJECT_NAME'..."
        ensure_vm_running
        cleanup_existing_container
        if orb -m "$VM_NAME" sudo docker images --format '{{.Repository}}' | grep -q "^${IMAGE_NAME}$"; then
            echo "   -> Removing image '$IMAGE_NAME'..."
            orb -m "$VM_NAME" sudo docker rmi "$IMAGE_NAME" >/dev/null 2>&1
        fi
        echo "‚úÖ Cleanup complete."
        ;;
esac
