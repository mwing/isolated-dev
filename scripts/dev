#!/bin/bash
set -e

# --- Configuration ---
VM_NAME="dev-vm-docker-host"
TEMPLATES_DIR="$HOME/.dev-envs/templates"
# --- End Configuration ---

# --- Helper Functions ---
function usage() {
    echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
    echo ""
    echo "A script to build and run isolated development containers using OrbStack VMs."
    echo ""
    echo "Commands:"
    echo "  run      Build and run the container (default)"
    echo "  build    Build the container image only"
    echo "  clean    Remove existing container and image"
    echo ""
    echo "Template Commands:"
    echo "  new <language>       Create a Dockerfile from template"
    echo "  new <language> --init Create Dockerfile and project scaffolding"
    echo "  list                 List available language templates"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -f, --file     Specify Dockerfile path (default: ./Dockerfile)"
    echo "  -t, --tag      Specify custom image tag"
    echo "  -n, --name     Specify custom container name"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0")                       # Build and run with default Dockerfile"
    echo "  $(basename "$0") build                # Build image only"
    echo "  $(basename "$0") -f Dockerfile.dev    # Use custom Dockerfile"
    echo "  $(basename "$0") new python           # Create from Python template"
    echo "  $(basename "$0") new python-3.13      # Create from specific Python version"
    echo "  $(basename "$0") new node-22 --init   # Create Node.js template with project scaffolding"
    echo "  $(basename "$0") list                 # Show available templates with versions"
    echo ""
    echo "Requirements:"
    echo "  - Dockerfile in current directory (or specified with -f)"
    echo "  - OrbStack VM '$VM_NAME' available"
    exit 0
}

function list_templates() {
    echo "Available Dockerfile templates:"
    if [[ -d "$TEMPLATES_DIR" ]]; then
        local templates_found=false
        
        # Create a simple formatted list
        printf "  %-12s %s\n" "Language" "Available Versions"
        printf "  %-12s %s\n" "--------" "------------------"
        
        # Process templates dynamically by discovering all languages
        local all_languages=$(ls "$TEMPLATES_DIR"/Dockerfile-* 2>/dev/null | grep -v '\.backup\.' | sed 's/.*Dockerfile-//' | sed 's/-.*$//' | sort -u)
        
        for lang in $all_languages; do
            local versions=""
            local version_count=0
            
            # Find all versions for this language
            for template_path in "$TEMPLATES_DIR/Dockerfile-$lang"-*; do
                if [[ -f "$template_path" ]] && [[ "$template_path" != *".backup."* ]]; then
                    local template_name=$(basename "$template_path" | sed 's/Dockerfile-//')
                    local version="${template_name#*-}"
                    
                    if [[ $version_count -eq 0 ]]; then
                        versions="$version"
                    else
                        versions="$versions, $version"
                    fi
                    ((version_count++))
                    found_templates=true
                    templates_found=true
                fi
            done
            
            # Display if we found templates for this language
            if [[ $version_count -gt 0 ]]; then
                printf "  %-12s %s\n" "$lang" "$versions"
            fi
        done
        
        if [[ "$templates_found" == false ]]; then
            echo "  (No templates found - run installer first)"
        fi
    else
        echo "  (Templates directory not found - run installer first)"
    fi
    exit 0
}

function init_project_scaffolding() {
    local language="$1"
    local base_lang="${language%%-*}"  # Extract base language (python, node, etc.)
    
    case "$base_lang" in
        python)
            echo "   -> Creating Python project structure..."
            
            # Create requirements.txt
            cat > requirements.txt << 'EOF'
# Python dependencies
# Add your project dependencies here
# Example:
# requests>=2.31.0
# flask>=3.0.0
EOF
            
            # Create main.py
            cat > main.py << 'EOF'
#!/usr/bin/env python3
"""
Main application entry point.
"""

def main():
    """Main function."""
    print("Hello from Python!")
    print("Edit this file to start building your application.")

if __name__ == "__main__":
    main()
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
env/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: requirements.txt, main.py, .gitignore"
            ;;
            
        node)
            echo "   -> Creating Node.js project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create package.json
            cat > package.json << EOF
{
  "name": "$project_name",
  "version": "1.0.0",
  "description": "A Node.js project",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {},
  "devDependencies": {}
}
EOF
            
            # Create index.js
            cat > index.js << 'EOF'
/**
 * Main application entry point
 */

console.log('Hello from Node.js!');
console.log('Edit this file to start building your application.');

// Example: Simple HTTP server
// const http = require('http');
// 
// const server = http.createServer((req, res) => {
//     res.writeHead(200, { 'Content-Type': 'text/plain' });
//     res.end('Hello World!\n');
// });
// 
// const PORT = process.env.PORT || 3000;
// server.listen(PORT, () => {
//     console.log(`Server running on port ${PORT}`);
// });
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: package.json, index.js, .gitignore"
            ;;
            
        golang)
            echo "   -> Creating Go project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create go.mod
            cat > go.mod << EOF
module $project_name

go 1.22

require ()
EOF
            
            # Create main.go
            cat > main.go << 'EOF'
package main

import "fmt"

func main() {
    fmt.Println("Hello from Go!")
    fmt.Println("Edit this file to start building your application.")
}
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
go.work

# Vendor
vendor/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: go.mod, main.go, .gitignore"
            ;;
            
        rust)
            echo "   -> Creating Rust project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create Cargo.toml
            cat > Cargo.toml << EOF
[package]
name = "$project_name"
version = "0.1.0"
edition = "2021"

[dependencies]
EOF
            
            # Create src directory and main.rs
            mkdir -p src
            cat > src/main.rs << 'EOF'
fn main() {
    println!("Hello from Rust!");
    println!("Edit this file to start building your application.");
}
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Rust
/target/
**/*.rs.bk
Cargo.lock

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: Cargo.toml, src/main.rs, .gitignore"
            ;;
            
        java)
            echo "   -> Creating Java project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create pom.xml for Maven
            cat > pom.xml << EOF
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>$project_name</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    
    <dependencies>
        <!-- Add your dependencies here -->
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
            </plugin>
        </plugins>
    </build>
</project>
EOF
            
            # Create src directory structure
            mkdir -p src/main/java/com/example
            cat > src/main/java/com/example/Main.java << 'EOF'
package com.example;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello from Java!");
        System.out.println("Edit this file to start building your application.");
    }
}
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Java
*.class
*.jar
*.war
*.ear
*.nar
hs_err_pid*

# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

# Gradle
.gradle/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: pom.xml, src/main/java/com/example/Main.java, .gitignore"
            ;;
            
        php)
            echo "   -> Creating PHP project structure..."
            
            # Create composer.json
            local project_name=$(basename "$(pwd)")
            cat > composer.json << EOF
{
    "name": "example/$project_name",
    "description": "A PHP project",
    "type": "project",
    "require": {
        "php": "^8.3"
    },
    "require-dev": {},
    "autoload": {
        "psr-4": {
            "App\\\\": "src/"
        }
    },
    "config": {
        "optimize-autoloader": true
    }
}
EOF
            
            # Create index.php
            cat > index.php << 'EOF'
<?php

require_once 'vendor/autoload.php';

echo "Hello from PHP!" . PHP_EOL;
echo "Edit this file to start building your application." . PHP_EOL;

// Example: Simple web response
// if (php_sapi_name() !== 'cli') {
//     header('Content-Type: text/html; charset=utf-8');
//     echo '<h1>Hello from PHP!</h1>';
//     echo '<p>Edit this file to start building your web application.</p>';
// }
EOF
            
            # Create src directory
            mkdir -p src
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# PHP
/vendor/
composer.lock
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: composer.json, index.php, src/, .gitignore"
            ;;
            
        bash)
            echo "   -> Creating Bash project structure..."
            
            # Create main script
            local project_name=$(basename "$(pwd)")
            cat > "$project_name.sh" << 'EOF'
#!/bin/bash

# Main script entry point
set -e

echo "Hello from Bash!"
echo "Edit this file to start building your shell application."

# Example function
main() {
    local arg="$1"
    
    if [[ -z "$arg" ]]; then
        echo "Usage: $0 <argument>"
        exit 1
    fi
    
    echo "You provided: $arg"
}

# Uncomment to run main function with arguments
# main "$@"
EOF
            
            chmod +x "$project_name.sh"
            
            # Create README.md
            cat > README.md << EOF
# $project_name

A Bash script project.

## Usage

\`\`\`bash
./$project_name.sh
\`\`\`

## Development

Edit \`$project_name.sh\` to start building your shell application.
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: $project_name.sh, README.md, .gitignore"
            ;;
            
        *)
            echo "   -> No specific scaffolding available for $base_lang"
            echo "   -> Created basic .gitignore"
            cat > .gitignore << 'EOF'
# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            ;;
    esac
}

function create_from_template() {
    local language="$1"
    local init_project="${2:-false}"
    local template_file=""
    local target_file="./Dockerfile"
    
    if [[ ! -d "$TEMPLATES_DIR" ]]; then
        echo "❌ Error: Templates directory not found at $TEMPLATES_DIR"
        echo "Please run the installer first."
        exit 1
    fi
    
    # Smart template matching logic
    # 1. Try exact match first (e.g., "python-3.13" -> "Dockerfile-python-3.13")
    if [[ -f "$TEMPLATES_DIR/Dockerfile-$language" ]]; then
        template_file="$TEMPLATES_DIR/Dockerfile-$language"
        echo "📋 Using template: $language"
    else
        # 2. Look for versioned templates that start with the language name
        local matching_templates=($(find "$TEMPLATES_DIR" -name "Dockerfile-${language}-*" -type f | grep -v '\.backup\.' 2>/dev/null))
        
        if [[ ${#matching_templates[@]} -eq 1 ]]; then
            # Found exactly one versioned template for this language
            template_file="${matching_templates[0]}"
            local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
            echo "📋 Using template: $template_name"
        elif [[ ${#matching_templates[@]} -gt 1 ]]; then
            # Multiple versions available, ask user to be specific
            echo "❌ Error: Multiple versions available for '$language'."
            echo "Please specify the version you want:"
            echo ""
            printf "  %-20s %s\n" "Template Name" "Usage"
            printf "  %-20s %s\n" "-------------" "-----"
            for template in "${matching_templates[@]}"; do
                local template_name=$(basename "$template" | sed 's/Dockerfile-//')
                printf "  %-20s %s\n" "$template_name" "dev new $template_name"
            done
            echo ""
            echo "Or run 'dev list' to see all available options."
            exit 1
        else
            # No templates found for this language
            echo "❌ Error: No template found for '$language'."
            echo "Available templates:"
            list_templates
            exit 1
        fi
    fi
    
    if [[ -f "$target_file" ]]; then
        echo "⚠️  Warning: Dockerfile already exists in current directory."
        echo -n "Do you want to overwrite it? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled."
            exit 0
        fi
    fi
    
    cp "$template_file" "$target_file" || {
        echo "❌ Error: Failed to copy template"
        exit 1
    }
    
    echo "✅ Created Dockerfile from $language template"
    
    # Initialize project scaffolding if requested
    if [[ "$init_project" == "true" ]]; then
        echo "🏗️  Initializing project scaffolding..."
        init_project_scaffolding "$language"
    fi
    
    echo "You can now run 'dev' to build and run your container."
    exit 0
}

# --- Parse Arguments ---
DOCKERFILE="Dockerfile"
COMMAND="run"
CUSTOM_TAG=""
CUSTOM_NAME=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        list)
            list_templates
            ;;
        new)
            if [[ -z "$2" ]]; then
                echo "❌ Error: new requires a language argument"
                echo "Use 'dev list' to see available options."
                exit 1
            fi
            # Check for --init flag
            init_project=false
            language="$2"
            if [[ "$3" == "--init" ]]; then
                init_project=true
            fi
            create_from_template "$language" "$init_project"
            ;;
        -f|--file)
            DOCKERFILE="$2"
            shift 2
            ;;
        -t|--tag)
            CUSTOM_TAG="$2"
            shift 2
            ;;
        -n|--name)
            CUSTOM_NAME="$2"
            shift 2
            ;;
        run|build|clean)
            COMMAND="$1"
            shift
            ;;
        *)
            echo "❌ Error: Unknown option '$1'"
            echo "Use --help for usage information."
            exit 1
            ;;
    esac
done

# --- Validate Requirements ---
if [[ "$COMMAND" != "clean" ]]; then
    if [ ! -f "$DOCKERFILE" ]; then
        echo "❌ Error: No Dockerfile found at '$DOCKERFILE'"
        echo "Use -f to specify a different Dockerfile path, or --help for usage information."
        exit 1
    fi
fi

# --- Validate Requirements ---
if [[ "$COMMAND" != "clean" ]]; then
    if [ ! -f "$DOCKERFILE" ]; then
        echo "❌ Error: No Dockerfile found at '$DOCKERFILE'"
        echo "Use -f to specify a different Dockerfile path, or --help for usage information."
        exit 1
    fi
fi

# --- Generate Names ---
PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
IMAGE_NAME="${CUSTOM_TAG:-dev-img-${PROJECT_NAME}}"
CONTAINER_NAME="${CUSTOM_NAME:-dev-ctn-${PROJECT_NAME}}"

# --- Helper Functions for Container Operations ---
ensure_vm_running() {
    if ! orb status "$VM_NAME" 2>/dev/null | grep -q "running"; then
        echo "   -> Starting Docker Host VM..."
        orb start "$VM_NAME"
    fi
}

build_image() {
    echo "   -> Building Docker image '$IMAGE_NAME'..."
    orb -m "$VM_NAME" sudo docker build -f "$DOCKERFILE" -t "$IMAGE_NAME" .
}

cleanup_existing_container() {
    if orb -m "$VM_NAME" sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "   -> Stopping existing container..."
        orb -m "$VM_NAME" sudo docker stop "$CONTAINER_NAME" >/dev/null 2>&1
        orb -m "$VM_NAME" sudo docker rm "$CONTAINER_NAME" >/dev/null 2>&1
    fi
}

# --- Main Logic ---
case $COMMAND in
    run)
        echo "🚀 Preparing isolated container for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        cleanup_existing_container
        echo "✅ Connecting to container. Your project folder is at '/app'."
        orb -m "$VM_NAME" sudo docker run -it --rm \
            -v "$(pwd):/app" \
            --name "$CONTAINER_NAME" \
            "$IMAGE_NAME"
        ;;
        
    build)
        echo "🔨 Building container image for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        echo "✅ Image '$IMAGE_NAME' built successfully."
        ;;
        
    clean)
        echo "🧹 Cleaning up containers and images for '$PROJECT_NAME'..."
        ensure_vm_running
        cleanup_existing_container
        if orb -m "$VM_NAME" sudo docker images --format '{{.Repository}}' | grep -q "^${IMAGE_NAME}$"; then
            echo "   -> Removing image '$IMAGE_NAME'..."
            orb -m "$VM_NAME" sudo docker rmi "$IMAGE_NAME" >/dev/null 2>&1
        fi
        echo "✅ Cleanup complete."
        ;;
esac
