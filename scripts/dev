#!/bin/bash
set -e

# ==============================================================================
# CONFIGURATION
# ==============================================================================

DEFAULT_VM_NAME="dev-vm-docker-host"
TEMPLATES_DIR="$HOME/.dev-envs/templates"
CONFIG_DIR="$HOME/.dev-envs"
GLOBAL_CONFIG="$CONFIG_DIR/config.yaml"
PROJECT_CONFIG=".devenv.yaml"

# ==============================================================================
# CONFIGURATION FUNCTIONS
# ==============================================================================

function load_config() {
    # Set defaults
    VM_NAME="$DEFAULT_VM_NAME"
    DEFAULT_TEMPLATE=""
    AUTO_START_VM="true"
    CONTAINER_PREFIX="dev"
    
    # Load global config if it exists
    if [[ -f "$GLOBAL_CONFIG" ]]; then
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            # Skip section headers like [profile.name]
            [[ "$line" =~ ^\[.*\] ]] && continue
            
            # Only process lines with equals sign
            if [[ "$line" =~ ^[[:space:]]*([^=]+)=[[:space:]]*(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                
                # Clean up key and value
                key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/^"//;s/"$//')
                
                case "$key" in
                    vm_name) VM_NAME="$value" ;;
                    default_template) DEFAULT_TEMPLATE="$value" ;;
                    auto_start_vm) AUTO_START_VM="$value" ;;
                    container_prefix) CONTAINER_PREFIX="$value" ;;
                esac
            fi
        done < "$GLOBAL_CONFIG"
    fi
    
    # Load project-local config if it exists (overrides global)
    if [[ -f "$PROJECT_CONFIG" ]]; then
        while IFS= read -r line; do
            # Skip comments and empty lines
            [[ "$line" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$line" ]] && continue
            # Skip section headers like [profile.name]
            [[ "$line" =~ ^\[.*\] ]] && continue
            
            # Only process lines with equals sign
            if [[ "$line" =~ ^[[:space:]]*([^=]+)=[[:space:]]*(.*)$ ]]; then
                key="${BASH_REMATCH[1]}"
                value="${BASH_REMATCH[2]}"
                
                # Clean up key and value
                key=$(echo "$key" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
                value=$(echo "$value" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//;s/^"//;s/"$//')
                
                case "$key" in
                    vm_name) VM_NAME="$value" ;;
                    default_template) DEFAULT_TEMPLATE="$value" ;;
                    auto_start_vm) AUTO_START_VM="$value" ;;
                    container_prefix) CONTAINER_PREFIX="$value" ;;
                esac
            fi
        done < "$PROJECT_CONFIG"
    fi
}

function create_default_config() {
    if [[ ! -f "$GLOBAL_CONFIG" ]]; then
        mkdir -p "$CONFIG_DIR"
        cat > "$GLOBAL_CONFIG" << 'EOF'
# Global configuration for isolated development environment
# This file uses simple key=value format

# Default VM name to use for containers
vm_name = "dev-vm-docker-host"

# Default template when language has multiple versions
# Leave empty to always prompt
default_template = ""

# Automatically start VM if not running
auto_start_vm = "true"

# Prefix for container and image names
container_prefix = "dev"

# You can also define environment profiles:
# [profile.database]
# vm_name = "dev-vm-database"
# 
# [profile.kubernetes]  
# vm_name = "dev-vm-k8s"
EOF
        echo "üìù Created default config at $GLOBAL_CONFIG"
        echo "   Edit this file to customize your development environment defaults."
    fi
}

# ==============================================================================
# UTILITY FUNCTIONS
# ==============================================================================

function handle_env_command() {
    local env_command="$1"
    local env_name="$2"
    local setup_dir="$HOME/.dev-envs/setups"
    
    case "$env_command" in
        new|up|down|rm|status)
            if [[ -z "$env_name" ]]; then
                echo "‚ùå Error: Environment name required"
                echo "Usage: $(basename "$0") env $env_command <environment>"
                echo ""
                echo "Available environments:"
                if [[ -d "$setup_dir" ]]; then
                    ls -1 "$setup_dir" | grep -v '\.backup\.' | sed 's/\..*$//' | sort -u | sed 's/^/  /'
                else
                    echo "  (No environments found - run installer first)"
                fi
                exit 1
            fi
            
            # Handle VM name construction - if env_name already starts with dev-vm-, use it as-is
            local vm_name
            if [[ "$env_name" == dev-vm-* ]]; then
                vm_name="$env_name"
                # Extract the actual environment name for setup file lookup
                local actual_env_name="${env_name#dev-vm-}"
                local setup_file=$(find "$setup_dir" -type f -name "${actual_env_name}.*" 2>/dev/null | head -n 1)
            else
                vm_name="dev-vm-${env_name}"
                local setup_file=$(find "$setup_dir" -type f -name "${env_name}.*" 2>/dev/null | head -n 1)
            fi
            
            case "$env_command" in
                new)
                    echo "üöÄ Creating and provisioning '$env_name' using cloud-init..."
                    if [[ ! -f "$setup_file" ]]; then
                        echo "‚ùå Error: Setup file for '$env_name' not found in $setup_dir"
                        echo ""
                        echo "Available environments:"
                        if [[ -d "$setup_dir" ]]; then
                            ls -1 "$setup_dir" | grep -v '\.backup\.' | sed 's/\..*$//' | sort -u | sed 's/^/  /'
                        fi
                        exit 1
                    fi
                    
                    orb create --user-data "$setup_file" ubuntu "$vm_name"
                    echo "‚úÖ Environment '$env_name' is ready. Connecting..."
                    orb -m "$vm_name"
                    ;;
                up)
                    echo "üöÄ Starting environment '$env_name' and connecting..."
                    orb -m "$vm_name"
                    ;;
                down)
                    echo "üõë Stopping environment '$env_name'..."
                    orb stop "$vm_name"
                    echo "‚úÖ VM '$vm_name' stopped."
                    ;;
                status)
                    echo "üìä Status of environment '$env_name':"
                    echo "   VM Name: $vm_name"
                    
                    # Check if VM exists in orb list and get its status
                    if orb list | grep -q "^$vm_name"; then
                        local vm_info=$(orb list | grep "^$vm_name")
                        local state=$(echo "$vm_info" | awk '{print $2}')
                        local distro=$(echo "$vm_info" | awk '{print $3}')
                        local ip=$(echo "$vm_info" | awk '{print $NF}')
                        
                        case "$state" in
                            running)
                                echo "   Status: ‚úÖ Running"
                                echo "   IP: $ip"
                                echo "   Distro: $distro"
                                ;;
                            stopped)
                                echo "   Status: ‚è∏Ô∏è  Stopped"
                                echo "   Distro: $distro"
                                ;;
                            *)
                                echo "   Status: $state"
                                ;;
                        esac
                    else
                        echo "   Status: ‚ùå VM not found"
                        echo ""
                        echo "üí° Available VMs:"
                        orb list | grep "^dev-vm-" | awk '{print "   " $1 " (" $2 ")"}'
                        if ! orb list | grep -q "^dev-vm-"; then
                            echo "   (No development VMs found)"
                            echo ""
                            echo "üí° Create one with: $(basename "$0") env new docker-host"
                        fi
                    fi
                    ;;
                rm)
                    echo "üî• Deleting environment '$env_name'..."
                    read -p "Are you sure you want to permanently delete VM '$vm_name'? (y/N) " -n 1 -r
                    echo
                    if [[ $REPLY =~ ^[Yy]$ ]]; then
                        orb delete "$vm_name"
                        echo "‚úÖ VM '$vm_name' deleted."
                    else
                        echo "Deletion cancelled."
                    fi
                    ;;
            esac
            ;;
        list|--help|-h|help)
            echo "Usage: $(basename "$0") env <command> [environment]"
            echo ""
            echo "Environment Management Commands:"
            echo "  new <env>        Create and provision a new environment VM"
            echo "  up <env>         Start an existing environment VM and connect"
            echo "  down <env>       Stop a running environment VM"
            echo "  status <env>     Show status of an environment VM"
            echo "  rm <env>         Delete an environment VM permanently"
            echo "  list             Show this help and available environments"
            echo ""
            echo "Available environments:"
            if [[ -d "$setup_dir" ]]; then
                ls -1 "$setup_dir" | grep -v '\.backup\.' | sed 's/\..*$//' | sort -u | sed 's/^/  /'
            else
                echo "  (No environments found - run installer first)"
            fi
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") env new docker-host    # Create Docker host VM"
            echo "  $(basename "$0") env up docker-host     # Start and connect to VM"
            echo "  $(basename "$0") env status docker-host # Check VM status"
            echo "  $(basename "$0") env down docker-host   # Stop VM to save resources"
            ;;
        *)
            echo "‚ùå Error: Unknown env command '$env_command'"
            echo "Use '$(basename "$0") env help' for usage information."
            exit 1
            ;;
    esac
}

function show_command_help() {
    local command="$1"
    case "$command" in
        new)
            echo "Usage: $(basename "$0") new <language> [--init]"
            echo ""
            echo "Create a Dockerfile from a language template."
            echo ""
            echo "Arguments:"
            echo "  <language>     Language template (python, node, golang, rust, java, php, bash)"
            echo "                 Optionally specify version: python-3.12, node-22, etc."
            echo ""
            echo "Options:"
            echo "  --init         Also create project scaffolding for the language"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") new python           # Latest Python template"
            echo "  $(basename "$0") new python-3.11      # Specific Python version"
            echo "  $(basename "$0") new node --init       # Node.js with package.json"
            echo "  $(basename "$0") new rust --init       # Rust with Cargo.toml"
            ;;
        config)
            echo "Usage: $(basename "$0") config [--edit|--init]"
            echo ""
            echo "Manage configuration files."
            echo ""
            echo "Options:"
            echo "  (no options)   Show current configuration"
            echo "  --edit         Edit global configuration in editor"
            echo "  --init         Create project-local configuration file"
            echo ""
            echo "Configuration Files:"
            echo "  Global:        ~/.dev-envs/config.yaml"
            echo "  Project-local: ./.devenv.yaml"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") config               # Show current config"
            echo "  $(basename "$0") config --edit        # Edit global config"
            echo "  $(basename "$0") config --init        # Create local config"
            ;;
        templates)
            echo "Usage: $(basename "$0") templates <action>"
            echo ""
            echo "Manage Dockerfile templates."
            echo ""
            echo "Actions:"
            echo "  update         Update all templates to latest versions"
            echo "  check          Check for available updates without applying"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") templates update     # Update all templates"
            echo "  $(basename "$0") templates check      # Check for updates"
            ;;
        troubleshoot)
            echo "Troubleshooting Guide:"
            echo ""
            echo "Common Issues:"
            echo ""
            echo "1. Container fails to start:"
            echo "   ‚Ä¢ Check if OrbStack is running: 'orb list'"
            echo "   ‚Ä¢ Verify VM is accessible: '$(basename "$0") env status docker-host'"
            echo "   ‚Ä¢ Try rebuilding: '$(basename "$0") clean && $(basename "$0") build'"
            echo ""
            echo "2. Port forwarding not working:"
            echo "   ‚Ä¢ Ensure your app binds to 0.0.0.0, not localhost"
            echo "   ‚Ä¢ Check if port is already in use on host"
            echo "   ‚Ä¢ Verify framework-specific files exist (package.json, requirements.txt)"
            echo ""
            echo "3. SSH keys not working:"
            echo "   ‚Ä¢ Check SSH agent is running: 'ssh-add -l'"
            echo "   ‚Ä¢ Verify SSH keys exist in ~/.ssh/"
            echo "   ‚Ä¢ Try adding keys to agent: 'ssh-add ~/.ssh/id_rsa'"
            echo ""
            echo "4. Template creation fails:"
            echo "   ‚Ä¢ Check internet connection (templates fetch from Docker Hub)"
            echo "   ‚Ä¢ Try updating templates: '$(basename "$0") templates update'"
            echo "   ‚Ä¢ Verify language name: '$(basename "$0") list'"
            echo ""
            echo "5. Performance issues:"
            echo "   ‚Ä¢ Package caches are automatically mounted for faster installs"
            echo "   ‚Ä¢ Consider using .dockerignore to exclude large directories"
            echo "   ‚Ä¢ Check disk space: 'df -h'"
            echo ""
            echo "For more help, visit: https://github.com/mwing/isolated-dev"
            ;;
        env)
            echo "Usage: $(basename "$0") env <command> [environment]"
            echo ""
            echo "Manage OrbStack VMs for isolated development environments."
            echo ""
            echo "Commands:"
            echo "  new <env>        Create and provision new environment VM"
            echo "  up <env>         Start existing environment VM and connect"
            echo "  down <env>       Stop running environment VM"
            echo "  status <env>     Show environment VM status"
            echo "  rm <env>         Delete environment VM permanently"
            echo "  list             List available environments"
            echo ""
            echo "Examples:"
            echo "  $(basename "$0") env new docker-host    # One-time setup"
            echo "  $(basename "$0") env up docker-host     # Start & connect"
            echo "  $(basename "$0") env down docker-host   # Stop to save battery"
            echo "  $(basename "$0") env status docker-host # Check if running"
            echo ""
            echo "Note: Most users only need the 'docker-host' environment."
            ;;
        *)
            echo "No specific help available for command: $command"
            echo "Use --help for general usage information."
            ;;
    esac
}

function usage() {
    echo "Usage: $(basename "$0") [OPTIONS] [COMMAND]"
    echo ""
    echo "A script to build and run isolated development containers using OrbStack VMs."
    echo ""
    echo "Commands:"
    echo "  run              Build and run the container (default)"
    echo "  shell            Open interactive bash shell in container"
    echo "  build            Build the container image only"
    echo "  clean            Remove existing container and image"
    echo ""
    echo "Environment Commands:"
    echo "  env <command>    Manage OrbStack VMs (new, up, down, status, rm)"
    echo "  env list         Show available environments and help"
    echo ""
    echo "Help Commands:"
    echo "  help             Show this help message"
    echo "  help <command>   Show help for specific command"
    echo "  troubleshoot     Show troubleshooting guide"
    echo ""
    echo "Template Commands:"
    echo "  new <language>       Create a Dockerfile from template"
    echo "  new <language> --init Create Dockerfile and project scaffolding"
    echo "  list                 List available language templates"
    echo "  templates update     Update templates to latest versions"
    echo "  templates check      Check for available template updates"
    echo ""
    echo "Configuration Commands:"
    echo "  config               Show current configuration"
    echo "  config --edit        Edit global configuration file"
    echo "  config --init        Create project-local configuration"
    echo ""
    echo "Options:"
    echo "  -h, --help     Show this help message"
    echo "  -f, --file     Specify Dockerfile path (default: ./Dockerfile)"
    echo "  -t, --tag      Specify custom image tag"
    echo "  -n, --name     Specify custom container name"
    echo ""
    echo "Enhanced Developer Experience:"
    echo "  ‚Ä¢ Automatic port forwarding detection (Node.js 3000, Python 8000, etc.)"
    echo "  ‚Ä¢ SSH key mounting for seamless git operations"
    echo "  ‚Ä¢ Git configuration sharing for consistent commits"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0") env new docker-host           # One-time VM setup"
    echo "  $(basename "$0")                              # Build and run with default Dockerfile"
    echo "  $(basename "$0") shell                        # Open interactive shell"
    echo "  $(basename "$0") new python                   # Create from Python template"
    echo "  $(basename "$0") new node-22 --init           # Create Node.js template with scaffolding"
    echo "  $(basename "$0") env down docker-host         # Stop VM to save battery"
    echo "  $(basename "$0") list                         # Show available templates with versions"
    echo ""
    echo "Requirements:"
    echo "  - Dockerfile in current directory (or specified with -f)"
    echo "  - OrbStack VM '$VM_NAME' available"
    exit 0
}

function list_templates() {
    echo "Available Dockerfile templates:"
    if [[ -d "$TEMPLATES_DIR" ]]; then
        local templates_found=false
        
        # Create a simple formatted list
        printf "  %-12s %s\n" "Language" "Available Versions"
        printf "  %-12s %s\n" "--------" "------------------"
        
        # Process templates dynamically by discovering all languages
        local all_languages=$(ls "$TEMPLATES_DIR"/Dockerfile-* 2>/dev/null | grep -v '\.backup\.' | sed 's/.*Dockerfile-//' | sed 's/-.*$//' | sort -u)
        
        for lang in $all_languages; do
            local versions=""
            local version_count=0
            
            # Find all versions for this language
            for template_path in "$TEMPLATES_DIR/Dockerfile-$lang"-*; do
                if [[ -f "$template_path" ]] && [[ "$template_path" != *".backup."* ]]; then
                    local template_name=$(basename "$template_path" | sed 's/Dockerfile-//')
                    local version="${template_name#*-}"
                    
                    if [[ $version_count -eq 0 ]]; then
                        versions="$version"
                    else
                        versions="$versions, $version"
                    fi
                    ((version_count++))
                    found_templates=true
                    templates_found=true
                fi
            done
            
            # Display if we found templates for this language
            if [[ $version_count -gt 0 ]]; then
                printf "  %-12s %s\n" "$lang" "$versions"
            fi
        done
        
        if [[ "$templates_found" == false ]]; then
            echo "  (No templates found - run installer first)"
        fi
    else
        echo "  (Templates directory not found - run installer first)"
    fi
    exit 0
}

# ==============================================================================
# TEMPLATE VERSION DETECTION FUNCTIONS
# ==============================================================================

function get_latest_python_version() {
    # Fetch latest stable Python version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/python/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^3\.[0-9]+$' | \
        sort -V | tail -1 2>/dev/null)
    echo "${latest:-3.14}"
}

function get_latest_node_version() {
    # Fetch latest stable Node.js version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/node/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^[0-9]+$' | \
        sort -n | tail -1 2>/dev/null)
    echo "${latest:-22}"
}

function get_latest_golang_version() {
    # Fetch latest stable Go version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/golang/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^1\.[0-9]+$' | \
        sort -V | tail -1 2>/dev/null)
    echo "${latest:-1.23}"
}

function get_latest_rust_version() {
    # Fetch latest stable Rust version from Docker Hub API
    local latest=$(curl -s --max-time 10 "https://registry.hub.docker.com/v2/repositories/library/rust/tags/?page_size=100" 2>/dev/null | \
        jq -r '.results[].name' 2>/dev/null | \
        grep -E '^1\.[0-9]+$' | \
        sort -V | tail -1 2>/dev/null)
    echo "${latest:-1.82}"
}

function check_template_updates() {
    echo "üîç Checking for latest template versions..."
    echo "‚è≥ Fetching current versions from official sources..."
    
    local templates_dir="$TEMPLATES_DIR"
    local missing_templates=()
    
    # Fetch current latest versions dynamically
    local python_latest="python-$(get_latest_python_version)"
    local node_latest="node-$(get_latest_node_version)"
    local golang_latest="golang-$(get_latest_golang_version)"
    local rust_latest="rust-$(get_latest_rust_version)"
    
    # Only check for languages where we can fetch latest versions
    local recommended=(
        "$python_latest"
        "$node_latest"
        "$golang_latest"
        "$rust_latest"
    )
    
    echo "üìã Latest versions detected:"
    for template in "${recommended[@]}"; do
        echo "  - $template"
    done
    echo ""
    
    # Check which templates are missing
    for template in "${recommended[@]}"; do
        if [[ ! -f "$templates_dir/Dockerfile-$template" ]]; then
            missing_templates+=("$template")
        fi
    done
    
    if [[ ${#missing_templates[@]} -eq 0 ]]; then
        echo "‚úÖ All latest template versions are available!"
    else
        echo "üì¶ Missing latest templates:"
        for template in "${missing_templates[@]}"; do
            echo "  - $template"
        done
        echo ""
        echo "üí° Run 'dev templates update' to create missing versions."
    fi
}

function update_templates() {
    echo "üîÑ Creating missing template versions..."
    echo "‚è≥ Fetching latest versions..."
    echo ""
    
    local templates_dir="$TEMPLATES_DIR"
    local created_count=0
    
    # Get latest versions dynamically
    local python_version=$(get_latest_python_version)
    local node_version=$(get_latest_node_version)
    local golang_version=$(get_latest_golang_version)
    local rust_version=$(get_latest_rust_version)
    
    # Python latest (if missing)
    if [[ ! -f "$templates_dir/Dockerfile-python-$python_version" ]]; then
        echo "üì¶ Adding Python $python_version template..."
        cat > "$templates_dir/Dockerfile-python-$python_version" << EOF
FROM python:$python_version-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    git \
    vim \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /workspace

# Install common Python development tools
RUN pip install --no-cache-dir \
    pip-tools \
    black \
    flake8 \
    pytest \
    ipython \
    jupyter

# Copy requirements if they exist
COPY requirements*.txt* ./
RUN if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

# Keep container running
CMD ["bash"]
EOF
        echo "   ‚úÖ Python $python_version template created"
        ((created_count++))
    fi
    
    # Node.js latest (if missing)  
    if [[ ! -f "$templates_dir/Dockerfile-node-$node_version" ]]; then
        echo "üì¶ Adding Node.js $node_version template..."
        cat > "$templates_dir/Dockerfile-node-$node_version" << EOF
FROM node:$node_version-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    vim \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /workspace

# Install common development tools
RUN npm install -g \
    nodemon \
    typescript \
    @types/node \
    eslint \
    prettier

# Copy package files if they exist
COPY package*.json* ./
RUN if [ -f package.json ]; then npm install; fi

# Keep container running
CMD ["bash"]
EOF
        echo "   ‚úÖ Node.js $node_version template created"
        ((created_count++))
    fi
    
    # Golang latest (if missing)
    if [[ ! -f "$templates_dir/Dockerfile-golang-$golang_version" ]]; then
        echo "üì¶ Adding Go $golang_version template..."
        cat > "$templates_dir/Dockerfile-golang-$golang_version" << EOF
FROM golang:$golang_version-bullseye

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    vim \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /workspace

# Install common Go tools
RUN go install golang.org/x/tools/cmd/goimports@latest && \
    go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest && \
    go install github.com/air-verse/air@latest

# Keep container running
CMD ["bash"]
EOF
        echo "   ‚úÖ Go $golang_version template created"
        ((created_count++))
    fi
    
    # Rust latest (if missing)
    if [[ ! -f "$templates_dir/Dockerfile-rust-$rust_version" ]]; then
        echo "üì¶ Adding Rust $rust_version template..."
        cat > "$templates_dir/Dockerfile-rust-$rust_version" << EOF
FROM rust:$rust_version-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    build-essential \
    pkg-config \
    libssl-dev \
    git \
    vim \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /workspace

# Install common Rust tools
RUN cargo install cargo-watch cargo-edit

# Copy Cargo files if they exist
COPY Cargo*.toml* ./
RUN if [ -f Cargo.toml ]; then cargo fetch; fi

# Keep container running
CMD ["bash"]
EOF
        echo "   ‚úÖ Rust $rust_version template created"
        ((created_count++))
    fi
    
    echo ""
    if [[ $created_count -gt 0 ]]; then
        echo "‚úÖ Template updates completed! Created $created_count new templates."
    else
        echo "‚úÖ All templates were already up to date."
    fi
    echo ""
    echo "üí° Tip: Use 'dev list' to see all available templates"
}

# ==============================================================================
# PROJECT SCAFFOLDING FUNCTIONS
# ==============================================================================

function init_project_scaffolding() {
    local language="$1"
    local base_lang="${language%%-*}"  # Extract base language (python, node, etc.)
    
    case "$base_lang" in
        python)
            echo "   -> Creating Python project structure..."
            
            # Create requirements.txt
            cat > requirements.txt << 'EOF'
# Python dependencies
# Add your project dependencies here
# Example:
# requests>=2.31.0
# flask>=3.0.0
EOF
            
            # Create main.py
            cat > main.py << 'EOF'
#!/usr/bin/env python3
"""
Main application entry point.
"""

def main():
    """Main function."""
    print("Hello from Python!")
    print("Edit this file to start building your application.")

if __name__ == "__main__":
    main()
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Virtual environments
venv/
env/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: requirements.txt, main.py, .gitignore"
            ;;
            
        node)
            echo "   -> Creating Node.js project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create package.json
            cat > package.json << EOF
{
  "name": "$project_name",
  "version": "1.0.0",
  "description": "A Node.js project",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "node --watch index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {},
  "devDependencies": {}
}
EOF
            
            # Create index.js
            cat > index.js << 'EOF'
/**
 * Main application entry point
 */

console.log('Hello from Node.js!');
console.log('Edit this file to start building your application.');

// Example: Simple HTTP server
// const http = require('http');
// 
// const server = http.createServer((req, res) => {
//     res.writeHead(200, { 'Content-Type': 'text/plain' });
//     res.end('Hello World!\n');
// });
// 
// const PORT = process.env.PORT || 3000;
// server.listen(PORT, () => {
//     console.log(`Server running on port ${PORT}`);
// });
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
logs
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: package.json, index.js, .gitignore"
            ;;
            
        golang)
            echo "   -> Creating Go project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Get latest Go version dynamically
            local go_version=$(get_latest_golang_version)
            
            # Create go.mod
            cat > go.mod << EOF
module $project_name

go $go_version

require ()
EOF
            
            # Create main.go
            cat > main.go << 'EOF'
package main

import "fmt"

func main() {
    fmt.Println("Hello from Go!")
    fmt.Println("Edit this file to start building your application.")
}
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Go
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
*.out
go.work

# Vendor
vendor/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: go.mod, main.go, .gitignore"
            ;;
            
        rust)
            echo "   -> Creating Rust project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create Cargo.toml
            cat > Cargo.toml << EOF
[package]
name = "$project_name"
version = "0.1.0"
edition = "2021"

[dependencies]
EOF
            
            # Create src directory and main.rs
            mkdir -p src
            cat > src/main.rs << 'EOF'
fn main() {
    println!("Hello from Rust!");
    println!("Edit this file to start building your application.");
}
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Rust
/target/
**/*.rs.bk
Cargo.lock

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: Cargo.toml, src/main.rs, .gitignore"
            ;;
            
        java)
            echo "   -> Creating Java project structure..."
            
            # Get project name from current directory
            local project_name=$(basename "$(pwd)")
            
            # Create pom.xml for Maven
            cat > pom.xml << EOF
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <groupId>com.example</groupId>
    <artifactId>$project_name</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>
    
    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
    
    <dependencies>
        <!-- Add your dependencies here -->
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.11.0</version>
            </plugin>
        </plugins>
    </build>
</project>
EOF
            
            # Create src directory structure
            mkdir -p src/main/java/com/example
            cat > src/main/java/com/example/Main.java << 'EOF'
package com.example;

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello from Java!");
        System.out.println("Edit this file to start building your application.");
    }
}
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# Java
*.class
*.jar
*.war
*.ear
*.nar
hs_err_pid*

# Maven
target/
pom.xml.tag
pom.xml.releaseBackup
pom.xml.versionsBackup
pom.xml.next
release.properties
dependency-reduced-pom.xml
buildNumber.properties
.mvn/timing.properties
.mvn/wrapper/maven-wrapper.jar

# Gradle
.gradle/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: pom.xml, src/main/java/com/example/Main.java, .gitignore"
            ;;
            
        php)
            echo "   -> Creating PHP project structure..."
            
            # Create composer.json
            local project_name=$(basename "$(pwd)")
            cat > composer.json << EOF
{
    "name": "example/$project_name",
    "description": "A PHP project",
    "type": "project",
    "require": {
        "php": "^8.3"
    },
    "require-dev": {},
    "autoload": {
        "psr-4": {
            "App\\\\": "src/"
        }
    },
    "config": {
        "optimize-autoloader": true
    }
}
EOF
            
            # Create index.php
            cat > index.php << 'EOF'
<?php

require_once 'vendor/autoload.php';

echo "Hello from PHP!" . PHP_EOL;
echo "Edit this file to start building your application." . PHP_EOL;

// Example: Simple web response
// if (php_sapi_name() !== 'cli') {
//     header('Content-Type: text/html; charset=utf-8');
//     echo '<h1>Hello from PHP!</h1>';
//     echo '<p>Edit this file to start building your web application.</p>';
// }
EOF
            
            # Create src directory
            mkdir -p src
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# PHP
/vendor/
composer.lock
*.log

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: composer.json, index.php, src/, .gitignore"
            ;;
            
        bash)
            echo "   -> Creating Bash project structure..."
            
            # Create main script
            local project_name=$(basename "$(pwd)")
            cat > "$project_name.sh" << 'EOF'
#!/bin/bash

# Main script entry point
set -e

echo "Hello from Bash!"
echo "Edit this file to start building your shell application."

# Example function
main() {
    local arg="$1"
    
    if [[ -z "$arg" ]]; then
        echo "Usage: $0 <argument>"
        exit 1
    fi
    
    echo "You provided: $arg"
}

# Uncomment to run main function with arguments
# main "$@"
EOF
            
            chmod +x "$project_name.sh"
            
            # Create README.md
            cat > README.md << EOF
# $project_name

A Bash script project.

## Usage

\`\`\`bash
./$project_name.sh
\`\`\`

## Development

Edit \`$project_name.sh\` to start building your shell application.
EOF
            
            # Create .gitignore
            cat > .gitignore << 'EOF'
# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            
            echo "   -> Created: $project_name.sh, README.md, .gitignore"
            ;;
            
        *)
            echo "   -> No specific scaffolding available for $base_lang"
            echo "   -> Created basic .gitignore"
            cat > .gitignore << 'EOF'
# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db
EOF
            ;;
    esac
}

# ==============================================================================
# DEVELOPER EXPERIENCE FUNCTIONS
# ==============================================================================

function detect_common_ports() {
    local ports=()
    
    # Check for common development files and add corresponding ports
    if [[ -f "package.json" ]]; then
        # Node.js common ports
        ports+=(3000 8080 5000 4000)
        
        # Check for specific frameworks in package.json
        if grep -q "next" package.json 2>/dev/null; then
            ports+=(3000)
        fi
        if grep -q "react-scripts" package.json 2>/dev/null; then
            ports+=(3000)
        fi
        if grep -q "vite" package.json 2>/dev/null; then
            ports+=(5173)
        fi
    fi
    
    if [[ -f "requirements.txt" ]] || [[ -f "pyproject.toml" ]] || [[ -f "setup.py" ]]; then
        # Python common ports
        ports+=(8000 5000 8080)
        
        # Check for specific frameworks
        if grep -q "flask" requirements.txt 2>/dev/null || grep -q "Flask" requirements.txt 2>/dev/null; then
            ports+=(5000)
        fi
        if grep -q "django" requirements.txt 2>/dev/null || grep -q "Django" requirements.txt 2>/dev/null; then
            ports+=(8000)
        fi
        if grep -q "fastapi" requirements.txt 2>/dev/null || grep -q "FastAPI" requirements.txt 2>/dev/null; then
            ports+=(8000)
        fi
    fi
    
    if [[ -f "go.mod" ]]; then
        # Go common ports
        ports+=(8080 8000 3000)
    fi
    
    if [[ -f "Cargo.toml" ]]; then
        # Rust common ports
        ports+=(8080 3000 8000)
    fi
    
    if [[ -f "composer.json" ]]; then
        # PHP common ports
        ports+=(8080 8000 80)
    fi
    
    if [[ -f "pom.xml" ]] || [[ -f "build.gradle" ]]; then
        # Java common ports
        ports+=(8080 8000 9000)
    fi
    
    # Remove duplicates and return
    printf '%s\n' "${ports[@]}" | sort -nu | tr '\n' ' '
}

function get_ssh_key_mounts() {
    local ssh_mounts=""
    
    # Mount SSH keys if they exist
    if [[ -d "$HOME/.ssh" ]]; then
        ssh_mounts="-v $HOME/.ssh:/root/.ssh:ro"
    fi
    
    echo "$ssh_mounts"
}

function get_common_volume_mounts() {
    local volumes=""
    
    # Always mount the current directory
    volumes="-v $(pwd):/workspace"
    
    # Mount git configuration if it exists
    if [[ -f "$HOME/.gitconfig" ]]; then
        volumes="$volumes -v $HOME/.gitconfig:/tmp/.gitconfig:ro"
    fi
    
    # Mount Docker socket for Docker-in-Docker development
    if [[ -S "/var/run/docker.sock" ]]; then
        volumes="$volumes -v /var/run/docker.sock:/var/run/docker.sock"
    fi
    
    echo "$volumes"
}

function build_port_forwards() {
    local ports=($(detect_common_ports))
    local port_args=""
    
    if [[ ${#ports[@]} -gt 0 ]]; then
        echo "üîå Detected common development ports: ${ports[*]}"
        for port in "${ports[@]}"; do
            port_args="$port_args -p $port:$port"
        done
    fi
    
    echo "$port_args"
}

# ==============================================================================
# COMMAND HANDLERS
# ==============================================================================

function handle_config_command() {
    local subcommand="$1"
    
    # Load configuration before processing commands
    load_config
    
    case "$subcommand" in
        --edit)
            create_default_config
            if command -v code >/dev/null 2>&1; then
                echo "üìù Opening config in VS Code..."
                code "$GLOBAL_CONFIG"
            elif command -v vim >/dev/null 2>&1; then
                echo "üìù Opening config in vim..."
                vim "$GLOBAL_CONFIG"
            else
                echo "üìù Edit your config file: $GLOBAL_CONFIG"
            fi
            exit 0
            ;;
        --init)
            if [[ -f "$PROJECT_CONFIG" ]]; then
                echo "‚ö†Ô∏è  Project config already exists: $PROJECT_CONFIG"
                echo -n "Do you want to overwrite it? (y/N): "
                read -r response
                if [[ ! "$response" =~ ^[Yy]$ ]]; then
                    echo "Operation cancelled."
                    exit 0
                fi
            fi
            
            cat > "$PROJECT_CONFIG" << EOF
# Project-specific configuration for $(basename "$(pwd)")
# This file uses simple key=value format and overrides global settings

# VM name for this project (uncomment to override global)
# vm_name = "dev-vm-$(basename "$(pwd)")"

# Default template for this project
# default_template = "python-3.13"

# Auto-start VM for this project
# auto_start_vm = "true"

# Container prefix for this project
# container_prefix = "$(basename "$(pwd)")"
EOF
            echo "‚úÖ Created project config: $PROJECT_CONFIG"
            echo "   Edit this file to customize settings for this project."
            exit 0
            ;;
        *)
            # Show current configuration
            create_default_config
            
            echo "üìã Current Configuration:"
            echo "  Global config: $GLOBAL_CONFIG"
            if [[ -f "$PROJECT_CONFIG" ]]; then
                echo "  Project config: $PROJECT_CONFIG (active)"
            else
                echo "  Project config: none"
            fi
            echo ""
            echo "  VM Name: $VM_NAME"
            echo "  Default Template: ${DEFAULT_TEMPLATE:-"(prompt for selection)"}"
            echo "  Auto Start VM: $AUTO_START_VM"
            echo "  Container Prefix: $CONTAINER_PREFIX"
            echo ""
            echo "Commands:"
            echo "  dev config --edit    Edit global configuration"
            echo "  dev config --init    Create project configuration"
            exit 0
            ;;
    esac
}

function create_from_template() {
    local language="$1"
    local init_project="${2:-false}"
    local template_file=""
    local target_file="./Dockerfile"
    
    if [[ ! -d "$TEMPLATES_DIR" ]]; then
        echo "‚ùå Error: Templates directory not found at $TEMPLATES_DIR"
        echo "Please run the installer first."
        exit 1
    fi
    
    # Smart template matching logic
    # 1. Try exact match first (e.g., "python-3.13" -> "Dockerfile-python-3.13")
    if [[ -f "$TEMPLATES_DIR/Dockerfile-$language" ]]; then
        template_file="$TEMPLATES_DIR/Dockerfile-$language"
        echo "üìã Using template: $language"
    else
        # 2. Look for versioned templates that start with the language name
        local matching_templates=($(find "$TEMPLATES_DIR" -name "Dockerfile-${language}-*" -type f | grep -v '\.backup\.' 2>/dev/null))
        
        if [[ ${#matching_templates[@]} -eq 1 ]]; then
            # Found exactly one versioned template for this language
            template_file="${matching_templates[0]}"
            local template_name=$(basename "$template_file" | sed 's/Dockerfile-//')
            echo "üìã Using template: $template_name"
        elif [[ ${#matching_templates[@]} -gt 1 ]]; then
            # Multiple versions available - check if we have a default configured
            if [[ -n "$DEFAULT_TEMPLATE" ]]; then
                # Check if the default template matches this language
                if [[ "$DEFAULT_TEMPLATE" == "$language"* ]]; then
                    for template in "${matching_templates[@]}"; do
                        local template_name=$(basename "$template" | sed 's/Dockerfile-//')
                        if [[ "$template_name" == "$DEFAULT_TEMPLATE" ]]; then
                            template_file="$template"
                            echo "üìã Using default template: $template_name"
                            break
                        fi
                    done
                fi
            fi
            
            # If no default found, ask user to be specific
            if [[ -z "$template_file" ]]; then
                echo "‚ùå Error: Multiple versions available for '$language'."
                echo "Please specify the version you want:"
                echo ""
                printf "  %-20s %s\n" "Template Name" "Usage"
                printf "  %-20s %s\n" "-------------" "-----"
                for template in "${matching_templates[@]}"; do
                    local template_name=$(basename "$template" | sed 's/Dockerfile-//')
                    printf "  %-20s %s\n" "$template_name" "dev new $template_name"
                done
                echo ""
                echo "Or run 'dev list' to see all available options."
                echo "Tip: Set a default with 'dev config --edit' to skip this prompt."
                exit 1
            fi
        else
            # No templates found for this language
            echo "‚ùå Error: No template found for '$language'."
            echo "Available templates:"
            list_templates
            exit 1
        fi
    fi
    
    if [[ -f "$target_file" ]]; then
        echo "‚ö†Ô∏è  Warning: Dockerfile already exists in current directory."
        echo -n "Do you want to overwrite it? (y/N): "
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "Operation cancelled."
            exit 0
        fi
    fi
    
    cp "$template_file" "$target_file" || {
        echo "‚ùå Error: Failed to copy template"
        exit 1
    }
    
    echo "‚úÖ Created Dockerfile from $language template"
    
    # Initialize project scaffolding if requested
    if [[ "$init_project" == "true" ]]; then
        echo "üèóÔ∏è  Initializing project scaffolding..."
        init_project_scaffolding "$language"
    fi
    
    echo "You can now run 'dev' to build and run your container."
    exit 0
}

# ==============================================================================
# MAIN EXECUTION
# ==============================================================================

# Initialize default values
DOCKERFILE="Dockerfile"
COMMAND="run"
CUSTOM_TAG=""
CUSTOM_NAME=""

# Process command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            usage
            ;;
        list)
            list_templates
            ;;
        templates)
            case "$2" in
                update)
                    update_templates
                    exit 0
                    ;;
                check)
                    check_template_updates
                    exit 0
                    ;;
                *)
                    echo "‚ùå Error: Unknown templates subcommand '$2'"
                    echo "Available: update, check"
                    exit 1
                    ;;
            esac
            ;;
        config)
            handle_config_command "$2"
            ;;
        new)
            if [[ -z "$2" ]]; then
                echo "‚ùå Error: new requires a language argument"
                echo "Use 'dev list' to see available options."
                exit 1
            fi
            # Check for --init flag
            init_project=false
            language="$2"
            if [[ "$3" == "--init" ]]; then
                init_project=true
            fi
            create_from_template "$language" "$init_project"
            ;;
        -f|--file)
            DOCKERFILE="$2"
            shift 2
            ;;
        -t|--tag)
            CUSTOM_TAG="$2"
            shift 2
            ;;
        -n|--name)
            CUSTOM_NAME="$2"
            shift 2
            ;;
        run|build|clean|shell)
            COMMAND="$1"
            shift
            ;;
        help)
            if [[ -n "$2" ]]; then
                show_command_help "$2"
            else
                usage
                echo ""
                echo "Available help topics:"
                echo "  $(basename "$0") help new           # Template creation help"
                echo "  $(basename "$0") help config        # Configuration help"
                echo "  $(basename "$0") help templates     # Template management help"
                echo "  $(basename "$0") help env           # Environment management help"
                echo "  $(basename "$0") troubleshoot       # Troubleshooting guide"
            fi
            exit 0
            ;;
        troubleshoot)
            show_command_help "troubleshoot"
            exit 0
            ;;
        env)
            handle_env_command "$2" "$3"
            exit 0
            ;;
        *)
            echo "‚ùå Error: Unknown option '$1'"
            echo "Available commands: run, shell, build, clean, new, list, config, templates, env, help, troubleshoot"
            echo "Use --help for usage information or 'help <command>' for command-specific help."
            exit 1
            ;;
    esac
done

# --- Load Configuration ---
load_config

# --- Validate Requirements ---
if [[ "$COMMAND" != "clean" ]]; then
    if [ ! -f "$DOCKERFILE" ]; then
        echo "‚ùå Error: No Dockerfile found at '$DOCKERFILE'"
        echo ""
        echo "üí° Suggestions:"
        echo "   ‚Ä¢ Create from template: '$(basename "$0") new <language>'"
        echo "   ‚Ä¢ Use different file: '$(basename "$0") -f /path/to/Dockerfile'"
        echo "   ‚Ä¢ See available templates: '$(basename "$0") list'"
        echo "   ‚Ä¢ Get help: '$(basename "$0") help new'"
        exit 1
    fi
fi

# --- Generate Names ---
PROJECT_NAME=$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]')
IMAGE_NAME="${CUSTOM_TAG:-${CONTAINER_PREFIX}-img-${PROJECT_NAME}}"
CONTAINER_NAME="${CUSTOM_NAME:-${CONTAINER_PREFIX}-ctn-${PROJECT_NAME}}"

# --- Helper Functions for Container Operations ---
ensure_vm_running() {
    if ! orb status "$VM_NAME" 2>/dev/null | grep -q "running"; then
        if [[ "$AUTO_START_VM" == "true" ]]; then
            echo "   -> Starting VM '$VM_NAME'..."
            orb start "$VM_NAME"
        else
            echo "‚ùå Error: VM '$VM_NAME' is not running"
            echo "   Start it manually with: dev env up docker-host"
            echo "   Or set auto_start_vm=true in your config"
            exit 1
        fi
    fi
}

build_image() {
    echo "   -> Building Docker image '$IMAGE_NAME'..."
    orb -m "$VM_NAME" sudo docker build -f "$DOCKERFILE" -t "$IMAGE_NAME" .
}

cleanup_existing_container() {
    if orb -m "$VM_NAME" sudo docker ps -a --format '{{.Names}}' | grep -q "^${CONTAINER_NAME}$"; then
        echo "   -> Stopping existing container..."
        orb -m "$VM_NAME" sudo docker stop "$CONTAINER_NAME" >/dev/null 2>&1
        orb -m "$VM_NAME" sudo docker rm "$CONTAINER_NAME" >/dev/null 2>&1
    fi
}

# --- Main Logic ---
case $COMMAND in
    run)
        echo "üöÄ Preparing isolated container for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        cleanup_existing_container
        
        # Build enhanced container options
        local volume_mounts=$(get_common_volume_mounts)
        local ssh_mounts=$(get_ssh_key_mounts)
        local port_forwards=$(build_port_forwards)
        
        echo "üîß Enhanced developer experience:"
        if [[ -n "$port_forwards" ]]; then
            echo "   -> Port forwarding enabled for detected services"
        fi
        if [[ -n "$ssh_mounts" ]]; then
            echo "   -> SSH keys mounted for git authentication"
        fi
        echo "   -> Git configuration mounted for consistent commits"
        echo ""
        echo "‚úÖ Connecting to container. Your project folder is at '/workspace'."
        
        orb -m "$VM_NAME" sudo docker run -it --rm \
            $volume_mounts \
            $ssh_mounts \
            $port_forwards \
            --name "$CONTAINER_NAME" \
            "$IMAGE_NAME"
        ;;
    shell)
        echo "üêö Opening interactive shell in '$PROJECT_NAME' container..."
        ensure_vm_running
        build_image
        cleanup_existing_container
        
        # Build enhanced container options
        local volume_mounts=$(get_common_volume_mounts)
        local ssh_mounts=$(get_ssh_key_mounts)
        local port_forwards=$(build_port_forwards)
        
        echo "üîß Enhanced developer experience:"
        if [[ -n "$port_forwards" ]]; then
            echo "   -> Port forwarding enabled for detected services"
        fi
        if [[ -n "$ssh_mounts" ]]; then
            echo "   -> SSH keys mounted for git authentication"
        fi
        echo "   -> Git configuration mounted for consistent commits"
        echo ""
        echo "‚úÖ Container ready. Your project folder is at '/workspace'."
        
        orb -m "$VM_NAME" sudo docker run -it --rm \
            $volume_mounts \
            $ssh_mounts \
            $port_forwards \
            --name "$CONTAINER_NAME" \
            "$IMAGE_NAME" bash
        ;;
    build)
        echo "üî® Building image for '$PROJECT_NAME'..."
        build_image
        echo "‚úÖ Image built successfully"
        ;;
        
    build)
        echo "üî® Building container image for '$PROJECT_NAME'..."
        ensure_vm_running
        build_image
        echo "‚úÖ Image '$IMAGE_NAME' built successfully."
        ;;
        
    clean)
        echo "üßπ Cleaning up containers and images for '$PROJECT_NAME'..."
        ensure_vm_running
        cleanup_existing_container
        if orb -m "$VM_NAME" sudo docker images --format '{{.Repository}}' | grep -q "^${IMAGE_NAME}$"; then
            echo "   -> Removing image '$IMAGE_NAME'..."
            orb -m "$VM_NAME" sudo docker rmi "$IMAGE_NAME" >/dev/null 2>&1
        fi
        echo "‚úÖ Cleanup complete."
        ;;
esac
